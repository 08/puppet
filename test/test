#!/usr/bin/env ruby

#------------------------------------------------------------
# Run any or all test suites.  This script is different from
# the Rakefile because it allows one to run one or more individual test methods
# easily.

require 'find'
require 'getoptlong'
include Find

def dirs
    Dir.glob("*").find_all { |d| FileTest.directory?(d) }.reject { |d|
        ["lib", "data"].include?(d)
    }
end

def rake(*args)
    print "trying %s..." % args.join(" ")
    output = %x{rake %s} % args.join(" ")

    if $?.exitstatus == 0
        puts "succeeded"
        return true
    else
        puts "failed"
        return false
    end
end

def resolve(dir)
    dirs = dirs()

    failed = nil
    dirs.each do |d|
        next if d == dir
        unless run([d, dir])
            failed = d
            break
        end
    end
    puts "%s failed" % failed

    files = ruby_files(failed)

    files.each do |file|
        unless run([file, dir])
            puts file
            exit(0)
        end
    end

    exit(1)
end

def ruby_files(dir)
    files = []
    # First collect the entire file list.
    begin
        find(dir) { |f| files << f if f =~ /\.rb$/ }
    rescue => detail
        puts "could not find on %s: %s" % [dir.inspect, detail]
    end
    files
end

def run(files, flags = nil)
    args = %w{ruby}
    args << "-Ilib:../lib"
    args << "lib/rake/puppet_test_loader.rb"
    if flags
        args += flags
    end
    args += ARGV

    print files.join(" ") + "... "
    $stdout.flush

    files.each do |file|
        case File.stat(file).ftype
        when "file": args << file
        when "directory": args += ruby_files(file)
        else
            $stderr.puts "Skipping %s; can't handle %s" %
                [file, File.stat(file).ftype]
        end
    end
    args = args.join(" ")
    if $options[:verbose]
        p args
    end
    output = %x{#{args} 2>&1}
    if $options[:debug]
        print output
    end

    if $?.exitstatus == 0
        puts "succeeded"
        return true
    else
        puts "failed"
        puts output
        return false
    end
end

result = GetoptLong.new(
    [ "--build",    "-b",			GetoptLong::NO_ARGUMENT ],
    [ "--debug",	"-d",			GetoptLong::NO_ARGUMENT ],
    [ "--verbose",	"-v",			GetoptLong::NO_ARGUMENT ],
    [ "-n",			                GetoptLong::REQUIRED_ARGUMENT ],
    [ "--files",    "-f",           GetoptLong::NO_ARGUMENT ],
    [ "--help",		"-h",			GetoptLong::NO_ARGUMENT ]
)

usage = "USAGE: %s [--help] suite" % $0

$options = {}
keep = []

result.each { |opt,arg|
    case opt
    when "--build"
        $options[:build] = true
    when "--verbose"
        $options[:verbose] = true
    when "--files"
        $options[:files] = true
    when "--debug"
        $options[:debug] = true
        $options[:verbose] = true
    when "--help"
        puts usage
        exit
    else
        keep << opt
        keep << arg if arg
    end
}

if $options[:files]
    run(ARGV, keep)
else
    dir = ARGV.shift

    unless dir
        $stderr.puts usage
        exit(1)
    end
    resolve(dir)
end
#
#
#files = []
#
#args.each do |test|
#    if FileTest.directory?(test)
#        files += ruby_files(test)
#    end
#end

## Now load all of our files.
#files.each do |file|
#    load file unless file =~ /^-/
#end
#
#runner = Test::Unit::AutoRunner.new(false) 
#runner.process_args
#runner.run
