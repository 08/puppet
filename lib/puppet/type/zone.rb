Puppet::Type.newtype(:zone) do
    @doc = "Solaris zones."

    # We should have a special state type for those states that modify
    # the zone's configuration.
    def self.newstate(name, &block) do
        super

        @states[name].class_eval do
            def cfgstate
                @cfgstate = true
            end

            def cfgstate?
                if defined? @cfgstate
                    @cfgstate
                else
                    false
                end
            end
        end
    end

    ensurable do
        desc "The running state of the zone.  The valid states directly reflect
            the states that ``zoneadm`` provides.  The states are linear,
            in that a zone must be ``configured`` then ``installed``, and
            only then can be ``running``.  Note also that ``halt`` is currently
            used to stop zones."

        @@list = [:absent, :configured, :installed, :running]

        newvalue(:absent) do
        end

        newvalue(:configured) do
            @parent.configure
            # Um, don't do anything for now...
        end

        newvalue(:installed) do
            begin
                execute("/usr/sbin/zlogin #{@parent[:name]} shutdown")
            rescue ExecutionFailure
                self.fail "Could not stop zone: %s" % output
            end
        end

        newvalue(:running) do
            begin
                execute("/usr/sbin/zoneadm #{@parent[:name]} boot")
            rescue ExecutionFailure
                self.fail "Could not stop zone: %s" % output
            end

            return :zone_booted
        end

        def perform(value)
        end
    end

    newparam(:name) do
        desc "The name of the zone."

        isnamevar
    end

    newparam(:id) do
        desc "The numerical ID of the zone.  This number is autogenerated
            and cannot be changed."
    end

    newstate(:ip) do
        desc "The IP address of the zone."

        # We need a generic IP address validation mechanism, and this library
        # needs to use it.

        cfgstate
    end

    newstate(:pool) do
        desc "The resource pool for this zone." 

        cfgstate
    end

    newstate(:inherits) do
        desc "The list of directories that the zone inherits from the global
            zone.  All directories must be fully qualified."


        cfgstate

        validate do |value|
            unless value =~ /^\//
                raise ArgumentError, "The zone base must be fully qualified"
            end
        end

        # Add a directory to our list of inherited directories.
        def adddir(dir)
            @parent.cfg "add inherit-pkg-dir
                set dir=#{dir}
                end"
        end

        # We want all specified directories to be included.
        def insync?
            @is == @should
        end

        def rmdir(dir)
            @parent.cfg "remove inherit-pkg-dir{dir=#{dir}}"
        end

        def sync
            [@is, @should].sort.uniq.each do |dir|
                # Skip directories that are configured and should be
                next if @is.include?(dir) and @should.include?(dir)

                if @is.include?(dir)
                    rmdir(dir)
                else
                    adddir(dir)
                end
            end
        end
    end

    newparam(:base) do
        desc "The root of the zone's filesystem.  Must be a fully qualified
            file name.  If you include '%s' in the path, then it will be
            replaced with the zone's name.  At this point, you cannot use
            Puppet to move a zone."

        validate do |value|
            unless value =~ /^\//
                raise ArgumentError, "The zone base must be fully qualified"
            end
        end

        munge do |value|
            if value =~ /%s/
                value % @parent[:name]
            else
                value
            end
        end
    end

    # If Puppet is also managing the base dir or its parent dir, list them
    # both as prerequisites.
    autorequire(:file) do
        if @parameters.include? :base
            return [@parameters[:base], File.dirname(@parameters[:base])]
        else
            nil
        end
    end

    # Convert the output of a list into a hash
    def self.line2hash(line)
        fields = [:id, :name, :status, :base]

        hash = {}
        line.split(":").each_with_index { |value, index|
            hash[fields[index]] = value
        }

        # Configured but not installed zones do not have IDs
        if hash[:id] == "-"
            hash.delete(:id)
        end

        return hash
    end

    def self.list
        %x{/usr/sbin/zoneadm list -cp}.split("\n").collect do |line|
            hash = line2hash(line)

            obj = nil
            unless obj = @objects[hash[:name]]
                obj = create(:name => hash[:name])
            end

            obj.setstatus(hash)

            obj
        end
    end

    # Execute a configuration string.
    def cfg(str)
        IO.popen("/usr/sbin/zonecfg -z %s" % @parent[:name], "w") do |pipe|
            pipe.puts str
        end

        unless $? == 0
            raise ArgumentError, "Failed to apply configuration"
        end
    end

    # Perform all of our configuration steps.
    def configure
        # If the thing is entirely absent, then we need to create the config.
        if @states[:status].is == :absent
            cfg("create; set zonepath=%s" % self[:base])
        end

        # Then perform all of our configuration steps.
        @states.each do |name, state|
            if state.class.cfgstate? and ! state.insync?
                state.sync
            end
        end
    end

    def create
        # First we must perform all of the configuration steps
        
        unless @parameters[:base]
            raise ArgumentError, "You must provide a zone root directory."
        end

        # Now do the rest of the steps.
        self.configure()

        # Then we must actually install the zone
        self.install()

        # And finally, boot it, if we're marked to do so.
    end

    def destroy
        if @states[:status].is == :running
            @states[:status].should = :stopped
            @states[:status].sync
        end

        begin
            execute("/usr/sbin/zoneadm #{@parent[:name]} uninstall")
        rescue ExecutionFailure
            self.fail "Could not stop zone: %s" % output
        end
    end

    # Collect the configuration of the zone.
    def info
        output = execute("/usr/sbin/zonecfg -z %s info" % self[:name])

        name = nil
        hash = {}
        output.split("\n").each do |line|
            case line
            when /^(\S+):\s*$/: name = $1
            when /^(\S+):\s*(.+)$/: hash[$1] = $2
            when /^\s+(\S+):\s*(.+)$/:
                if name
                    unless hash[name].is_a? Hash
                        hash[name] = {}
                    end
                    hash[name][$1] = $2
                else
                    err "Ignoring '%s'" % line
                end
            else
                debug "Ignoring zone output '%s'" % line
            end
        end
    end

    def install
    end

    def retrieve
        begin
            output = execute("/usr/sbin/zoneadm -z #{self[:name]} list -p")
        rescue ExecutionFailure
            @states[:ensure] = :absent
            return
        end

        hash = self.class.line2hash(output.chomp)
        setstatus(hash)
    end

    # Take the results of a listing and set everything appropriately.
    def setstatus(hash)
        hash.each do |param, value|
            next if param == :name
            case self.class.attrtype(param)
            when :state:
                self.is = [param, value]
            else
                self[param] = value
            end
        end
    end
end

# $Id$
