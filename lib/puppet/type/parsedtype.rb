require 'etc'
require 'facter'
require 'puppet/type/state'

module Puppet
    class State
        class ParsedParam < Puppet::State
            @name = :parsedparam
            # Normally this would retrieve the current value, but our state is not
            # actually capable of doing so.
            def retrieve
                unless defined? @is and ! @is.nil?
                    @is = :notfound
                end
            end

            # Determine whether the host entry should be destroyed, and figure
            # out which event to return.  Finally, call @parent.sync to write the
            # host tab.
            def sync(nostore = false)
                ebase = @parent.class
                if @is == :notfound
                    @is = self.should
                    tail = "created"
                elsif self.should == :notfound
                    @parent.remove(true)
                    tail = "deleted"
                elsif self.insync?
                    return nil
                else
                    @is = self.should
                    tail = "changed"
                end

                unless nostore
                    @parent.store
                end
                
                return (ebase + "_" + tail).intern
            end
        end
    end

    class Type
        # The collection of classes that are just simple records aggregated
        # into a file. See 'host.rb' for an example.
        class ParsedType < Puppet::Type
            @name = :parsedtype
            class << self
                attr_accessor :filetype, :hostfile, :fileobj, :fields, :path
            end

            # Override 'newstate' so that all states default to having the
            # correct parent type
            def self.newstate(name, parent = nil, &block)
                parent ||= Puppet::State::ParsedParam
                super(name, parent, &block)
            end

            # Add another type var.
            def self.initvars
                @instances = []
                super
            end

            # Override the Puppet::Type#[]= method so that we can store the
            # instances in per-user arrays.  Then just call +super+.
            def self.[]=(name, object)
                self.instance(object)
                super
            end

            # In addition to removing the instances in @objects, Cron has to remove
            # per-user host tab information.
            def self.clear
                @instances = []
                @fileobj = nil
                super
            end

            # Override the default Puppet::Type method, because instances
            # also need to be deleted from the @instances hash
            def self.delete(child)
                if @instances.include?(child)
                    @instances.delete(child)
                end
                super
            end

            # Return the header placed at the top of each generated file, warning
            # users that modifying this file manually is probably a bad idea.
            def self.header
%{# This file was autogenerated at #{Time.now} by puppet.  While it
# can still be managed manually, it is definitely not recommended.\n\n}
            end

            # Store a new instance of a host.  Called from Host#initialize.
            def self.instance(obj)
                unless @instances.include?(obj)
                    @instances << obj
                end
            end

            # Parse a file
            #
            # Subclasses must override this method.
            def self.parse(text)
                raise Puppet::DevError, "Parse was not overridden in %s" %
                    self.name
            end

            # Convert the hash to an object.
            def self.hash2obj(hash)
                obj = nil

                unless hash.include?(:name) and hash[:name]
                    raise Puppet::DevError, "Hash was not passed with name"
                end

                # if the obj already exists with that name...
                if obj = self[hash[:name]]
                    # do nothing...
                else
                    # create a new obj, since no existing one seems to
                    # match
                    obj = self.create(
                        :name => hash[:name]
                    ) or return false
                    hash.delete(:name)
                end

                hash.each { |param, value|
                    obj.is = [param, value]
                }
            end

            # Retrieve the text for the file. Returns nil in the unlikely
            # event that it doesn't exist.
            def self.retrieve
                @fileobj ||= @filetype.new(@path)
                text = @fileobj.read
                if text.nil? or text == ""
                    # there is no host file
                    return nil
                else
                    self.parse(text)
                end
            end

            # Write out the file.
            def self.store
                @fileobj ||= @filetype.new(@path)

                if @instances.empty?
                    Puppet.notice "No host instances for %s" % user
                else
                    @fileobj.write(self.to_file())
                end
            end

            # Collect all Host instances convert them into literal text.
            def self.to_file
                str = self.header()
                unless @instances.empty?
                    str += @instances.collect { |obj|
                        obj.to_s
                    }.join("\n") + "\n"

                    return str
                else
                    Puppet.notice "No host instances for %s" % user
                    return ""
                end
            end

            # Return the last time the hosts file was loaded.  Could
            # be used for reducing writes, but currently is not.
            def self.loaded?(user)
                @fileobj ||= @filetype.new(@path)
                @fileobj.loaded
            end

            # Override the default Puppet::Type method because we need to call
            # the +@filetype+ retrieve method.
            def retrieve
                self.class.retrieve()
                self.eachstate { |st| st.retrieve }
            end

            # Write the entire host file out.
            def store
                self.class.store()
            end
        end
    end
end

# $Id$
