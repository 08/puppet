# vim: syntax=ruby

# the parser

class Puppet::Parser::Parser

token LBRACK DQTEXT SQTEXT RBRACK LBRACE RBRACE SYMBOL FARROW COMMA TRUE
token FALSE EQUALS LESSEQUAL NOTEQUAL DOT COLON TYPE
token QMARK LPAREN RPAREN ISEQUAL GREATEREQUAL GREATERTHAN LESSTHAN
token IF ELSE IMPORT DEFINE ELSIF VARIABLE CLASS INHERITS NODE BOOLEAN
token NAME SEMIC CASE DEFAULT AT LCOLLECT RCOLLECT

# We have 2 shift/reduce conflicts
#expect 2

rule
program:    statements {
    # Make sure we always return an array.
    if val[0].is_a?(AST::ASTArray)
        result = val[0]
    else
        result = aryfy(val[0])
    end
}
            | nothing

statements: statement
            | statements statement {
    if val[0].instance_of?(AST::ASTArray)
        val[0].push(val[1])
        result = val[0]
    else
        result = ast AST::ASTArray, :children => [val[0],val[1]]
    end
}

# The main list of valid statements
statement:    object
            | collectable
            | collection
            | assignment
            | casestatement
            | ifstatement
            | import
            | fstatement
            | definition
            | hostclass
            | nodedef

fstatement:   NAME LPAREN classnames RPAREN {
    args = aryfy(val[2])
    result = ast AST::Function,
        :name => val[0],
        :arguments => args,
        :ftype => :statement
}
            | NAME classnames {
    args = aryfy(val[1])
    result = ast AST::Function,
        :name => val[0],
        :arguments => args,
        :ftype => :statement
}

# Includes are just syntactic sugar for classes with no names and
# no arguments.
#include:    INCLUDE classnames {
#    result = function_include(val[1])
#}

# Define a new tag.  Both of these functions should really be done generically,
# but I'm not in a position to do that just yet. :/
#tag:        TAG classnames {
#    result = function_tag(val[1])
#}

classnames:       classname
                | classnames COMMA classname {
    result = aryfy(val[0], val[2])
    result.line = @lexer.line
    result.file = @lexer.file
}

classname:        name
                | variable
                | quotedtext

#object:       name LBRACE objectname COLON params endcomma RBRACE {
object:       name LBRACE objectinstances endsemi RBRACE {
    if val[0].instance_of?(AST::ASTArray)
        raise Puppet::ParseError, "Invalid name"
    end
    array = val[2]
    if array.instance_of?(AST::ObjectInst)
        array = [array]
    end
    result = ast AST::ASTArray

    # this iterates across each specified objectinstance
    array.each { |instance|
        unless instance.instance_of?(AST::ObjectInst)
            raise Puppet::Dev, "Got something that isn't an instance"
        end
        # now, i need to somehow differentiate between those things with
        # arrays in their names, and normal things
        result.push ast(AST::ObjectDef,
            :type => val[0],
            :name => instance[0],
            :params => instance[1])
    }
}           | name LBRACE params endcomma RBRACE {
    if val[0].instance_of?(AST::ASTArray)
        Puppet.notice "invalid name"
        raise Puppet::ParseError, "Invalid name"
    end
    # an object but without a name
    # this cannot be an instance of a library type
    result = ast AST::ObjectDef, :type => val[0], :params => val[2]

}           | type LBRACE params endcomma RBRACE {
    # a template setting for a type
    if val[0].instance_of?(AST::ASTArray)
        raise Puppet::ParseError, "Invalid type"
    end
    result = ast(AST::TypeDefaults, :type => val[0], :params => val[2])
}

# Collectable objects; these get stored in the database, instead of
# being passed to the client.
collectable:    AT object {
    unless Puppet[:storeconfigs]
        raise Puppet::ParseError, "You cannot collect without storeconfigs being set"
    end

    if val[1].is_a? AST::TypeDefaults
        raise Puppet::ParseError, "Defaults are not collectable"
    end

    # Just mark our objects as collectable and pass them through.
    if val[1].instance_of?(AST::ASTArray)
        val[1].each do |obj|
            obj.collectable = true
        end
    else
        val[1].collectable = true
    end

    result = val[1]
}

# A collection statement.  Currently supports no arguments at all, but eventually
# will, I assume.
collection:     name LCOLLECT RCOLLECT {
    unless Puppet[:storeconfigs]
        raise Puppet::ParseError, "You cannot collect without storeconfigs being set"
    end
    result = ast AST::Collection, :type => val[0]
}

objectinst:   objectname COLON params endcomma {
    result = ast AST::ObjectInst, :children => [val[0],val[2]]
}

objectinstances:   objectinst
                 | objectinstances SEMIC objectinst {
    if val[0].instance_of?(AST::ObjectInst)
        result = ast AST::ASTArray, :children => [val[0],val[2]]
    else
        val[0].push val[2]
        result = val[0]
    end
}

endsemi:      # nothing
            | SEMIC

name:         NAME {
    result = ast AST::Name, :value => val[0]
}

type:         TYPE {
    result = ast AST::Type, :value => val[0]
}

objectname:   quotedtext
            | name
            | type
            | selector
            | variable
            | array

assignment:     VARIABLE EQUALS rvalue {
    # this is distinct from referencing a variable
    variable = ast AST::Name, :value => val[0].sub(/^\$/,'')
    result = ast AST::VarDef, :name => variable, :value => val[2]
}

params:   # nothing
{
    result = ast AST::ASTArray
}
        | param { result = val[0] }
        | params COMMA param {
    if val[0].instance_of?(AST::ASTArray)
        val[0].push(val[2])
        result = val[0]
    else
        result = ast AST::ASTArray, :children => [val[0],val[2]]
    end
}

param:        NAME FARROW rvalue {
    leaf = ast AST::String, :value => val[0]
    result = ast AST::ObjectParam, :param => leaf, :value => val[2]
}

rvalues:      rvalue
            | rvalues comma rvalue {
    if val[0].instance_of?(AST::ASTArray)
        result = val[0].push(val[2])
    else
        result = ast AST::ASTArray, :children => [val[0],val[2]]
    end
}

rvalue:       quotedtext
            | name
            | type
            | boolean
            | selector
            | variable
            | array
            | objectref
            | funcrvalue

# We currently require arguments in these functions.
funcrvalue:   NAME LPAREN classnames RPAREN {
    args = aryfy(val[2])
    result = ast AST::Function,
        :name => val[0],
        :arguments => args,
        :ftype => :rvalue
}

quotedtext: DQTEXT {
    result = ast AST::String, :value => val[0]
}           | SQTEXT {
    result = ast AST::FlatString, :value => val[0]
}

boolean:    BOOLEAN {
    result = ast AST::Boolean, :value => val[0]
}

objectref: name LBRACK rvalue RBRACK {
    result = ast AST::ObjectRef, :type => val[0], :name => val[2]
}

ifstatement:      IF iftest LBRACE statements RBRACE else {
    args = {
        :test => val[1],
        :statements => val[3]
    }

    if val[5]
        args[:else] = val[5]
    end

    result = ast AST::IfStatement, args
}

else:             # nothing
                | ELSE LBRACE statements RBRACE {
    result = ast AST::Else, :statements => val[2]
}

# Currently we only support a single value, but eventually one assumes
# we'll support operators and such.
iftest:         rvalue

casestatement:  CASE rvalue LBRACE caseopts RBRACE {
    options = val[3]
    unless options.instance_of?(AST::ASTArray)
        options = ast AST::ASTArray, :children => [val[3]]
    end
    result = ast AST::CaseStatement, :test => val[1], :options => options
}

caseopts:     caseopt
            | caseopts caseopt {
    if val[0].instance_of?(AST::ASTArray)
        val[0].push val[1]
        result = val[0]
    else
        result = ast AST::ASTArray, :children => [val[0], val[1]]
    end
}

caseopt:        casevalues COLON LBRACE statements RBRACE {
    result = ast AST::CaseOpt, :value => val[0], :statements => val[3]
}               | casevalues COLON LBRACE RBRACE {
    result = ast(AST::CaseOpt,
        :value => val[0],
        :statements => ast(AST::ASTArray)
    )
}

casevalues:       selectlhand
                | casevalues COMMA selectlhand {
    if val[0].instance_of?(AST::ASTArray)
        val[0].push(val[2])
        result = val[0]
    else
        result = ast AST::ASTArray, :children => [val[0],val[2]]
    end
}

selector:     selectlhand QMARK svalues {
    result = ast AST::Selector, :param => val[0], :values => val[2]
}

svalues:      selectval
            | LBRACE sintvalues RBRACE { result = val[1] }

sintvalues:   selectval
            | sintvalues comma selectval {
    if val[0].instance_of?(AST::ASTArray)
        val[0].push(val[2])
        result = val[0]
    else
        result = ast AST::ASTArray, :children => [val[0],val[2]]
    end
}

selectval:        selectlhand FARROW rvalue {
    result = ast AST::ObjectParam, :param => val[0], :value => val[2]
}

selectlhand:  name
            | type
            | quotedtext
            | variable
            | funcrvalue
            | boolean
            | DEFAULT {
    result = ast AST::Default, :value => val[0]
}

import: IMPORT quotedtext {
    # importing files
    # yuk, i hate keywords
    # we'll probably have to have some kind of search path eventually
    # but for now, just use a path relative to the file doing the importing
    dir = @lexer.file.sub(%r{[^/]+$},'').sub(/\/$/, '')
    if dir == ""
        dir = "."
    end
    result = ast AST::ASTArray

    Dir.chdir(dir) {
        # We can't interpolate at this point since we don't have any 
        # scopes set up. Warn the user if they use a variable reference
        pat = val[1].value
        if pat.index("$")
             Puppet.warning(
                 "The import of #{pat} contains a variable reference;" +
                 " variables are not interpolated for imports " +
                 "in file #{@lexer.file} at line #{@lexer.line}"
             )
        end
        files = Dir.glob(pat)
        if files.size == 0
            files = Dir.glob(pat + ".pp")
            if files.size == 0
                raise Puppet::ImportError.new("No file(s) found for import " + 
                                              "of '#{pat}'")
            end
        end

        files.each { |file|
            parser = Puppet::Parser::Parser.new()
            parser.files = self.files
            Puppet.debug("importing '%s'" % file)

            unless file =~ /^#{File::SEPARATOR}/
                file = File.join(dir, file)
            end
            begin
                parser.file = file
            rescue Puppet::ImportError
                Puppet.warning(
                    "Importing %s would result in an import loop" %
                        File.join(dir, file)
                )
                next
            end
            # push the results into the main result array
            # We always return an array when we parse.
            parser.parse.each do |child|
                result.push child
            end
        }
    }
}

# Disable definition inheritance for now. 8/27/06, luke
#definition: DEFINE NAME argumentlist parent LBRACE statements RBRACE {
definition: DEFINE NAME argumentlist LBRACE statements RBRACE {
    args = {
        :type => ast(AST::Name, :value => val[1]),
        :args => val[2],
        :code => val[4] # Switch to 5 for parents
    }

    if val[3].instance_of?(AST::Name)
        args[:parentclass] = val[3]
    end
    result = ast AST::CompDef, args
#}           | DEFINE NAME argumentlist parent LBRACE RBRACE {
}           | DEFINE NAME argumentlist LBRACE RBRACE {
    args = {
        :type => ast(AST::Name, :value => val[1]),
        :args => val[2],
        :code => ast(AST::ASTArray)
    }

    if val[3].instance_of?(AST::Name)
        args[:parentclass] = val[3]
    end

    result = ast AST::CompDef, args
}

#hostclass: CLASS NAME argumentlist parent LBRACE statements RBRACE {
hostclass: CLASS NAME parent LBRACE statements RBRACE {
        #:args => val[2],
    args = {
        :type => ast(AST::Name, :value => val[1]),
        :code => val[4]
    }
    # It'll be an ASTArray if we didn't get a parent
    if val[2].instance_of?(AST::Name)
        args[:parentclass] = val[2]
    end
    result = ast AST::ClassDef, args
}           | CLASS NAME parent LBRACE RBRACE {
    args = {
        :type => ast(AST::Name, :value => val[1]),
        :code => ast(AST::ASTArray, :children => [])
    }
    # It'll be an ASTArray if we didn't get a parent
    if val[2].instance_of?(AST::Name)
        args[:parentclass] = val[2]
    end
    result = ast AST::ClassDef, args
}

nodedef: NODE hostnames parent LBRACE statements RBRACE {
    unless val[1].instance_of?(AST::ASTArray)
        val[1] = ast AST::ASTArray,
            :line => val[1].line,
            :file => val[1].file,
            :children => [val[1]]
    end
    args = {
        :names => val[1],
        :code => val[4]
    }
    if val[2].instance_of?(AST::Name)
        args[:parentclass] = val[2]
    end
    result = ast AST::NodeDef, args
}       |  NODE hostnames parent LBRACE RBRACE {
    unless val[1].instance_of?(AST::ASTArray)
        val[1] = ast AST::ASTArray,
            :line => val[1].line,
            :file => val[1].file,
            :children => [val[1]]
    end
    args = {
        :names => val[1],
        :code => ast(AST::ASTArray, :children => [])
    }
    if val[2].instance_of?(AST::Name)
        args[:parentclass] = val[2]
    end
    result = ast AST::NodeDef,args
}

# Multiple hostnames, as used for node names.
hostnames:    hostname 
  | hostnames COMMA hostname {
    if val[0].instance_of?(AST::ASTArray)
        result = val[0]
        result.push val[2]
    else
        result = ast AST::ASTArray, :children => [val[0], val[2]]
    end
}

hostname: NAME {
   result = ast AST::HostName, :value => val[0]
}        | SQTEXT {
   result = ast AST::HostName, :value => val[0]
}        | DEFAULT {
   result = ast AST::Default, :value => val[0]
}

nothing:    {
    result = ast AST::ASTArray, :children => []
}

argumentlist: nothing
            | LPAREN nothing RPAREN {
    result = val[1]
}
            | LPAREN arguments RPAREN {
    if val[1].instance_of?(AST::ASTArray)
        result = val[1]
    else
        result = ast AST::ASTArray, :children => [val[1]]
    end
}

arguments:    argument
            | arguments COMMA argument {
    if val[0].instance_of?(AST::ASTArray)
        val[0].push(val[2])
        result = val[0]
    else
        result = ast AST::ASTArray, :children => [val[0],val[2]]
    end
}

argument:     name EQUALS rvalue {
    msg = "Deprecation notice:  #{val[0].value} must now include '$' in prototype"
    msg += " at line %s" % @lexer.line
    msg += " in file %s" % @lexer.file if @lexer.file
    Puppet.warning msg
    result = ast AST::CompArgument, :children => [val[0],val[2]]
}
            | name {
    msg = "Deprecation notice:  #{val[0].value} must now include '$' in prototype"
    msg += " at line %s" % @lexer.line
    msg += " in file %s" % @lexer.file if @lexer.file
    Puppet.warning msg
    result = ast AST::CompArgument, :children => [val[0]]
}           | lvariable EQUALS rvalue {
    result = ast AST::CompArgument, :children => [val[0],val[2]]
}           | lvariable {
    result = ast AST::CompArgument, :children => [val[0]]
}

parent:       nothing
            | INHERITS NAME {
    result = ast AST::Name, :value => val[1]
}

variable:     VARIABLE {
    name = val[0].sub(/^\$/,'')
    result = ast AST::Variable, :value => name
}

# This is variables as lvalues; we're assigning them, not deferencing them.
lvariable:     VARIABLE {
    result = ast AST::Name, :value => val[0].sub(/^\$/,'')
}

array:        LBRACK rvalues RBRACK {
    if val[1].instance_of?(AST::ASTArray)
        result = val[1]
    else
        result = ast AST::ASTArray, :children => [val[1]]
    end
}           | LBRACK RBRACK {
    result = ast AST::ASTArray
}

comma:        FARROW
            | COMMA

endcomma:     # nothing
            | COMMA { result = nil }

end
---- header ----
require 'puppet'
require 'puppet/parsedfile'
require 'puppet/parser/lexer'
require 'puppet/parser/ast'
#require 'puppet/parser/interpreter'

module Puppet
    class ParseError < Puppet::Error; end

    class ImportError < Racc::ParseError; end
end

Puppet[:typecheck] = true
Puppet[:paramcheck] = true

---- inner ----
require 'puppet/parser/functions'

attr_reader :file
attr_accessor :files

# Create an AST array out of all of the args
def aryfy(*args)
    if args[0].instance_of?(AST::ASTArray)
        result = args.shift
        args.each { |arg|
            result.push arg
        }
    else
        result = ast AST::ASTArray, :children => args
    end

    return result
end

# Create an AST object, and automatically add the file and line information if
# available.
def ast(klass, hash = nil)
    hash ||= {}
    unless hash[:line]
        hash[:line] = @lexer.line
    end

    unless hash[:file]
        if file = @lexer.file
            hash[:file] = file
        end
    end

    return klass.new(hash)
end

def file=(file)
    unless FileTest.exists?(file)
        unless file =~ /\.pp$/
            file = file + ".pp"
        end
        unless FileTest.exists?(file)
            raise Puppet::Error, "Could not find file %s" % file
        end
    end
    if @files.detect { |f| f.file == file }
        raise Puppet::ImportError.new("Import loop detected")
    else
        @files << Puppet::ParsedFile.new(file)
        @lexer.file = file
    end
end

def initialize
    @lexer = Puppet::Parser::Lexer.new()
    @files = []
    #if Puppet[:debug]
    #    @yydebug = true
    #end
end

def on_error(token,value,stack)
    #on '%s' at '%s' in\n'%s'" % [token,value,stack]
    #error = "line %s: parse error after '%s'" %
    #    [@lexer.line,@lexer.last]
    error = "Syntax error at '%s'" % [value]

    #if Puppet[:debug]
        #puts stack.inspect
        #puts stack.class
    #end
    #if @lexer.file
    #    error += (" in '%s'" % @lexer.file)
    #end

    except = Puppet::ParseError.new(error)
    except.line = @lexer.line
    if @lexer.file
        except.file = @lexer.file
    end

    raise except
end

# how should I do error handling here?
def parse(string = nil)
    if string
        self.string = string
    end
    begin
        yyparse(@lexer,:scan)
    rescue Racc::ParseError => except
        error = Puppet::ParseError.new(except)
        error.line = @lexer.line
        error.file = @lexer.file
        error.backtrace = except.backtrace
        raise error
    rescue Puppet::ParseError => except
        except.line ||= @lexer.line
        except.file ||= @lexer.file
        raise except
    rescue Puppet::Error => except
        # and this is a framework error
        except.line ||= @lexer.line
        except.file ||= @lexer.file
        #if Puppet[:debug]
        #    puts except.stack
        #end
        raise except
    rescue Puppet::DevError => except
        except.line ||= @lexer.line
        except.file ||= @lexer.file
        #if Puppet[:debug]
        #    puts except.stack
        #end
        raise except
    rescue => except
        error = Puppet::DevError.new(except.message)
        error.line = @lexer.line
        error.file = @lexer.file
        error.backtrace = except.backtrace
        #if Puppet[:debug]
        #    puts caller
        #end
        raise error
    end
end

def reparse?
    @files.detect { |file|
        file.changed?
    }
end

def string=(string)
    @lexer.string = string
end

# Make emacs happy
# Local Variables:
# mode: ruby
# End:

# $Id$

