#
# DO NOT MODIFY!!!!
# This file is automatically generated by racc 1.4.4
# from racc grammer file "grammar.ra".
#

require 'racc/parser'


require 'blink/parser/lexer'
#require 'blink/parser/interpreter'

module Blink
    class ParseError < Racc::ParseError; end
end


module Blink

  module Parser

    class Parser < Racc::Parser

module_eval <<'..end grammar.ra modeval..id5273b1fd0f', 'grammar.ra', 171
def file=(file)
    @lexer.file = file
end

def initialize
    @lexer = Blink::Parser::Lexer.new()
    if Blink[:debug]
        @yydebut = true
    end
end

def on_error(token,value,stack)
    #puts "Parse stack:"
    #puts stack
    #on '%s' at '%s' in\n'%s'" % [token,value,stack]
    error = "line %s: parse error after '%s'" % [@lexer.line,@lexer.last]

    if @lexer.file
        error += (" in '%s'" % @lexer.file)
    end

    raise Blink::ParseError.new(error)
end

# how should I do error handling here?
def parse
    yyparse(@lexer,:scan)
    #begin
    #    yyparse(@lexer,:scan)
    #rescue Racc::ParseError => detail
    #    raise Racc::ParseError.new("line %s: parse error after '%s'" %
    #        [@lexer.line,@lexer.last])
    #end
end

def string=(string)
    @lexer.string = string
end

# the parent class for all of our syntactical objects
class AST
    attr_accessor :line
    @@pink = "[0;31m"
    @@green = "[0;32m"
    @@yellow = "[0;33m"
    @@reset = "[0m"

    @@indent = " " * 4
    @@indline = @@pink + ("-" * 4) + @@reset
    @@midline = @@yellow + ("-" * 4) + @@reset

    def AST.indention
        return @@indent * @@indention
    end

    def AST.midline
        return @@midline
    end

    def typewrap(string)
        #return self.class.to_s.sub(/.+::/,'') + "(" + @@green + string +@@reset+ ")"
        return @@green + string +@@reset+ "(" + self.class.to_s.sub(/.+::/,'') + ")"
    end

    def initialize(*rest)
        begin
            args = Hash[*rest]
        rescue ArgumentError
            raise ArgumentError.new("Arguments must be passed as name => value pairs")
        end
        args.each { |param,value|
            method = param.to_s + "="
            unless self.respond_to?(method)
                raise "Invalid parameter %s to object class %s" %
                    [method,self.class.to_s]
            end

            begin
                #Blink.debug("sending %s to %s" % [method, self.class])
                self.send(method,value)
            rescue => detail
                # XXX this should be more normal error correction
                raise "Could not set parameter %s on class %s: %s" %
                    [method,self.class.to_s,detail]
            end
        }
    end

    class ASTArray < Array
        def tree(indent = 0)
            #puts((AST.indent * indent) + self.pin)
            self.collect { |child|
                child.tree(indent)
            }.join("\n" + (AST.midline * (indent+1)) + "\n")
        end
    end

    # this differentiation is used by the interpreter
    # XXX i now need a standard mechanism for descending into children

    # these objects have children
    class Branch < AST
        include Enumerable
        attr_accessor :pin

        def each
            @children.each { |child|
                yield child
            }
        end

        def tree(indent = 0)
            return ((@@indline * indent) + self.typewrap(self.pin)) + "\n" +
            self.collect { |child|
                child.tree(indent + 1)
            }.join("\n")
        end
    end

    # and these ones don't
    class Leaf < AST
        attr_accessor :value, :type

        def tree(indent = 0)
            return ((@@indent * indent) + self.typewrap(self.value))
        end

        def to_s
            return @value
        end
    end

    class String < AST::Leaf
        attr_accessor :value
    end

    class Word < AST::Leaf
        attr_accessor :value
    end

    class ObjectDef < AST::Branch
        attr_accessor :name, :object
        attr_reader :params

        def []=(index,obj)
            @params[index] = obj
        end

        def [](index)
            return @params[index]
        end

        def each
            #Blink.debug("each called on %s" % self)
            [@object,@name,@params].flatten.each { |param|
                #Blink.debug("yielding param %s" % param)
                yield param
            }
        end

        def initialize(*args)
            super(*args)
        end

        def params=(params)
            if params.is_a?(Array)
                @params = params
            else
                @params = [params]
            end
        end

        def tree(indent = 0)
            return [
                @object.tree(indent + 1),
                @name.tree(indent + 1),
                ((@@indline * indent) + self.typewrap(self.pin)),
                @params.collect { |param|
                    begin
                        param.tree(indent + 1)
                    rescue NoMethodError => detail
                        puts "failed to tree"
                        puts @params
                        p param
                        raise
                    end
                }.join("\n")
            ].join("\n")
        end

        def to_s
            return "%s => { %s }" % [@name,
                @params.collect { |param|
                    param.to_s
                }.join("\n")
            ]
        end
    end

    class ObjectParam < AST::Branch
        attr_accessor :value, :param

        def each
            [@param,@value].each { |child| yield child }
        end

        def tree(indent = 0)
            return [
                @param.tree(indent + 1),
                ((@@indline * indent) + self.typewrap(self.pin)),
                @value.tree(indent + 1)
            ].join("\n")
        end

        def to_s
            return "%s => %s" % [@param,@value]
        end
    end

    class Selector < AST::Branch
        attr_accessor :param, :value

        def tree(indent = 0)
            return [
                @param.tree(indent + 1),
                ((@@indline * indent) + self.typewrap(self.pin)),
                @value.tree(indent + 1)
            ].join("\n")
        end

        def each
            [@param,@value].each { |child| yield child }
        end
    end

    class VarDef < AST::Branch
        attr_accessor :name, :value

        def each
            [@name,@value].each { |child| yield child }
        end

        def tree(indent = 0)
            return [
                @name.tree(indent + 1),
                ((@@indline * 4 * indent) + self.typewrap(self.pin)),
                @value.tree(indent + 1)
            ].join("\n")
        end

        def to_s
            return "%s => %s" % [@name,@value]
        end
    end

    class FunctionCall < AST::Branch
        attr_accessor :name, :values

        def each
            [@name,@values].each { |child| yield child }
        end

        def tree(indent = 0)
            return [
                @name.tree(indent + 1),
                ((@@indline * 4 * indent) + self.typewrap(self.pin)),
                @values.tree(indent + 1)
            ].join("\n")
        end

        def to_s
            return "%s => %s" % [@name,@values]
        end
    end
end
..end grammar.ra modeval..id5273b1fd0f

##### racc 1.4.4 generates ###

racc_reduce_table = [
 0, 0, :racc_error,
 1, 18, :_reduce_1,
 1, 19, :_reduce_none,
 2, 19, :_reduce_3,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 1, 20, :_reduce_none,
 8, 21, :_reduce_8,
 3, 22, :_reduce_9,
 1, 26, :_reduce_10,
 3, 26, :_reduce_11,
 3, 28, :_reduce_12,
 1, 29, :_reduce_none,
 2, 29, :_reduce_14,
 1, 25, :_reduce_15,
 1, 25, :_reduce_none,
 1, 25, :_reduce_none,
 1, 25, :_reduce_none,
 3, 23, :_reduce_19,
 1, 30, :_reduce_none,
 3, 30, :_reduce_21,
 1, 31, :_reduce_none,
 2, 31, :_reduce_23,
 4, 24, :_reduce_24,
 3, 24, :_reduce_25,
 0, 27, :_reduce_none,
 1, 27, :_reduce_27 ]

racc_reduce_n = 28

racc_shift_n = 46

racc_action_table = [
    17,    17,    19,    19,    21,    30,    11,    38,    11,    17,
    21,    19,    22,    29,    35,    27,     9,    10,    12,    10,
    12,    17,    17,    19,    19,    21,    33,     3,    13,     3,
    39,    21,    43,    44,    21 ]

racc_action_check = [
    28,    12,    28,    12,    32,    21,     3,    32,    17,    11,
    10,    11,    10,    13,    28,    12,     3,     3,     3,    17,
    17,    30,     9,    30,     9,    22,    25,     6,     5,     0,
    33,    39,    40,    42,    43 ]

racc_action_pointer = [
    27,   nil,   nil,     3,   nil,    28,    25,   nil,   nil,    20,
     6,     7,    -1,    13,   nil,   nil,   nil,     5,   nil,   nil,
   nil,    -4,    21,   nil,   nil,    21,   nil,   nil,    -2,   nil,
    19,   nil,     0,    24,   nil,   nil,   nil,   nil,   nil,    27,
    22,   nil,    26,    30,   nil,   nil ]

racc_action_default = [
   -28,    -5,    -6,   -28,    -7,   -28,    -1,    -2,    -4,   -28,
   -28,   -28,   -28,   -28,    -3,   -16,   -18,   -28,    -9,   -15,
   -17,   -28,   -28,   -20,   -19,   -28,   -13,   -25,   -28,    46,
   -28,   -22,   -28,   -28,   -14,   -24,   -12,   -23,   -21,   -28,
   -26,   -10,   -28,   -27,    -8,   -11 ]

racc_goto_table = [
    23,     8,    18,     7,    25,    26,     5,     8,     2,    14,
     4,    40,    31,    42,     2,     6,     4,    28,    24,    32,
   nil,    34,    37,    36,   nil,   nil,   nil,   nil,   nil,    41,
   nil,   nil,   nil,    45 ]

racc_goto_check = [
    11,     4,     8,     3,     8,     8,     1,     4,     6,     3,
     7,     9,    11,    10,     6,     2,     7,    12,    13,    14,
   nil,     8,    11,     8,   nil,   nil,   nil,   nil,   nil,    11,
   nil,   nil,   nil,    11 ]

racc_goto_pointer = [
   nil,     6,    15,     3,     1,   nil,     8,    10,    -7,   -28,
   -27,   -10,     5,     8,    -3 ]

racc_goto_default = [
   nil,   nil,   nil,   nil,    20,     1,    15,    16,   nil,   nil,
   nil,   nil,   nil,   nil,   nil ]

racc_token_table = {
 false => 0,
 Object.new => 1,
 :WORD => 2,
 :LBRACK => 3,
 :QTEXT => 4,
 :RBRACK => 5,
 :LBRACE => 6,
 :RBRACE => 7,
 :SYMBOL => 8,
 :FARROW => 9,
 :COMMA => 10,
 :TRUE => 11,
 :FALSE => 12,
 :EQUALS => 13,
 :QMARK => 14,
 :LPAREN => 15,
 :RPAREN => 16 }

racc_use_result_var = true

racc_nt_base = 17

Racc_arg = [
 racc_action_table,
 racc_action_check,
 racc_action_default,
 racc_action_pointer,
 racc_goto_table,
 racc_goto_check,
 racc_goto_default,
 racc_goto_pointer,
 racc_nt_base,
 racc_reduce_table,
 racc_token_table,
 racc_shift_n,
 racc_reduce_n,
 racc_use_result_var ]

Racc_token_to_s_table = [
'$end',
'error',
'WORD',
'LBRACK',
'QTEXT',
'RBRACK',
'LBRACE',
'RBRACE',
'SYMBOL',
'FARROW',
'COMMA',
'TRUE',
'FALSE',
'EQUALS',
'QMARK',
'LPAREN',
'RPAREN',
'$start',
'program',
'statements',
'statement',
'object',
'assignment',
'selector',
'functioncall',
'rvalue',
'params',
'endcomma',
'param',
'rvalues',
'svalues',
'sintvalues']

Racc_debug_parser = false

##### racc system variables end #####

 # reduce 0 omitted

module_eval <<'.,.,', 'grammar.ra', 31
  def _reduce_1( val, _values, result )
    if val[0].is_a?(Array)
        result = val[0]
    else
        result = AST::ASTArray.new([val[0]])
    end
    # this is mainly so we can test the parser separately from the
    # interpreter
    if Blink[:parseonly]
        begin
            puts result.tree(0)
        rescue NoMethodError => detail
            puts detail
            exit(78)
        end
    else
        require 'blink/parser/interpreter'
        result = Blink::Parser::Interpreter.new(result)
    end
   result
  end
.,.,

 # reduce 2 omitted

module_eval <<'.,.,', 'grammar.ra', 41
  def _reduce_3( val, _values, result )
    if val[0].is_a?(Array)
        val[0].push(val[1])
        result = val[0]
    else
        result = AST::ASTArray.new([val[0],val[1]])
    end
   result
  end
.,.,

 # reduce 4 omitted

 # reduce 5 omitted

 # reduce 6 omitted

 # reduce 7 omitted

module_eval <<'.,.,', 'grammar.ra', 60
  def _reduce_8( val, _values, result )
    leaf = AST::Word.new(
        :line => @lexer.line,
        :value => val[0]
    )
    result = AST::ObjectDef.new(
        :pin => "[]",
        :line => @lexer.line,
        :object => leaf,
        :name => val[2],
        :params => val[5]
    )
   result
  end
.,.,

module_eval <<'.,.,', 'grammar.ra', 73
  def _reduce_9( val, _values, result )
    leaf = AST::Word.new(
        :line => @lexer.line,
        :value => val[0]
    )
    result = AST::VarDef.new(
        :pin => "=",
        :line => @lexer.line,
        :name => leaf,
        :value => val[2]
    )
   result
  end
.,.,

module_eval <<'.,.,', 'grammar.ra', 74
  def _reduce_10( val, _values, result )
 result = val[0]
   result
  end
.,.,

module_eval <<'.,.,', 'grammar.ra', 83
  def _reduce_11( val, _values, result )
    if val[0].is_a?(Array)
        val[0].push(val[2])
        result = val[0]
    else
        result = [val[0],val[2]]
    end
   result
  end
.,.,

module_eval <<'.,.,', 'grammar.ra', 96
  def _reduce_12( val, _values, result )
    leaf = AST::String.new(
        :line => @lexer.line,
        :value => val[0]
    )
    result = AST::ObjectParam.new(
        :pin => "=>",
        :line => @lexer.line,
        :param => leaf,
        :value => val[2]
    )
   result
  end
.,.,

 # reduce 13 omitted

module_eval <<'.,.,', 'grammar.ra', 105
  def _reduce_14( val, _values, result )
    if val[0].is_a?(Array)
        result = val[0].push(val[1])
    else
        result = AST::Array.new(val[0],val[1])
    end
   result
  end
.,.,

module_eval <<'.,.,', 'grammar.ra', 112
  def _reduce_15( val, _values, result )
    result = AST::String.new(
        :line => @lexer.line,
        :value => val[0]
    )
   result
  end
.,.,

 # reduce 16 omitted

 # reduce 17 omitted

 # reduce 18 omitted

module_eval <<'.,.,', 'grammar.ra', 128
  def _reduce_19( val, _values, result )
    leaf = AST::Word.new(
        :line => @lexer.line,
        :value => val[0]
    )
    result = AST::Selector.new(
        :pin => "?",
        :line => @lexer.line,
        :param => leaf,
        :value => val[2]
    )
   result
  end
.,.,

 # reduce 20 omitted

module_eval <<'.,.,', 'grammar.ra', 131
  def _reduce_21( val, _values, result )
 result = val[1]
   result
  end
.,.,

 # reduce 22 omitted

module_eval <<'.,.,', 'grammar.ra', 142
  def _reduce_23( val, _values, result )
    if val[0].is_a?(Array)
        val[0].push(val[1])
        result = val[0]
    else
        result = AST::ASTArray.new([val[0],val[1]])
    end
   result
  end
.,.,

module_eval <<'.,.,', 'grammar.ra', 150
  def _reduce_24( val, _values, result )
    result = AST::FunctionCall.new(
        :pin => '()',
        :name => AST::Word.new(:value => val[0], :line => @lexer.line),
        :values => val[2]
    )
   result
  end
.,.,

module_eval <<'.,.,', 'grammar.ra', 156
  def _reduce_25( val, _values, result )
    result = FunctionDef.new(
        :pin => '()',
        :name => val[0]
    )
   result
  end
.,.,

 # reduce 26 omitted

module_eval <<'.,.,', 'grammar.ra', 158
  def _reduce_27( val, _values, result )
 result = nil
   result
  end
.,.,

 def _reduce_none( val, _values, result )
  result
 end

    end   # class Parser

  end   # module Parser

end   # module Blink
