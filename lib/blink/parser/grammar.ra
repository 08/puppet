#/usr/bin/ruby

# $Id$
# vim: syntax=ruby

# the parser

class Blink::Parser::Parser
token WORD LBRACK QTEXT RBRACK LBRACE RBRACE SYMBOL FARROW COMMA TRUE FALSE EQUALS
token QMARK LPAREN RPAREN
rule
program:    statements {
    if val[0].is_a?(Array)
        result = val[0]
    else
        result = AST::ASTArray.new([val[0]])
    end
    # this is mainly so we can test the parser separately from the
    # interpreter
    if Blink[:parseonly]
        begin
            puts result.tree(0)
        rescue NoMethodError => detail
            puts detail
            exit(78)
        end
    else
        require 'blink/parser/interpreter'
        result = Blink::Parser::Interpreter.new(result)
    end
}

statements:   statement
            | statements statement {
    if val[0].is_a?(Array)
        val[0].push(val[1])
        result = val[0]
    else
        result = AST::ASTArray.new([val[0],val[1]])
    end
}

statement:    object
            | assignment
            | selector
            | functioncall
            
object:     WORD LBRACK rvalue RBRACK LBRACE params endcomma RBRACE {
    leaf = AST::Word.new(
        :line => @lexer.line,
        :value => val[0]
    )
    result = AST::ObjectDef.new(
        :pin => "[]",
        :line => @lexer.line,
        :object => leaf,
        :name => val[2],
        :params => val[5]
    )
}

assignment:     WORD EQUALS rvalue {
    leaf = AST::Word.new(
        :line => @lexer.line,
        :value => val[0]
    )
    result = AST::VarDef.new(
        :pin => "=",
        :line => @lexer.line,
        :name => leaf,
        :value => val[2]
    )
}

params:   param { result = val[0] }
        | params COMMA param {
    if val[0].is_a?(Array)
        val[0].push(val[2])
        result = val[0]
    else
        result = [val[0],val[2]]
    end
}

param:        QTEXT FARROW rvalue {
    leaf = AST::String.new(
        :line => @lexer.line,
        :value => val[0]
    )
    result = AST::ObjectParam.new(
        :pin => "=>",
        :line => @lexer.line,
        :param => leaf,
        :value => val[2]
    )
}

rvalues:      rvalue
            | rvalues rvalue {
    if val[0].is_a?(Array)
        result = val[0].push(val[1])
    else
        result = AST::Array.new(val[0],val[1])
    end
}

rvalue:       QTEXT {
    result = AST::String.new(
        :line => @lexer.line,
        :value => val[0]
    )
}
            | selector
            | object
            | functioncall
            | WORD { # these are variable names
    result = AST::Word.new(
        :line => @lexer.line,
        :value => val[0]
    )
}

selector:     WORD QMARK svalues {
    leaf = AST::Word.new(
        :line => @lexer.line,
        :value => val[0]
    )
    result = AST::Selector.new(
        :pin => "?",
        :line => @lexer.line,
        :param => leaf,
        :value => val[2]
    )
}

# I'm probably going to regret reusing 'param' here...
svalues:      param
            | LBRACE sintvalues RBRACE { result = val[1] }

sintvalues:   param
            | sintvalues param {
    if val[0].is_a?(Array)
        val[0].push(val[1])
        result = val[0]
    else
        result = AST::ASTArray.new([val[0],val[1]])
    end
}

functioncall: WORD LPAREN rvalues RPAREN {
    result = AST::FunctionCall.new(
        :pin => '()',
        :name => AST::Word.new(:value => val[0], :line => @lexer.line),
        :values => val[2]
    )
}
            | WORD LPAREN RPAREN {
    result = FunctionDef.new(
        :pin => '()',
        :name => val[0]
    )
}

endcomma:     # nothing
            | COMMA { result = nil }

end
---- header ----
require 'blink/parser/lexer'
#require 'blink/parser/interpreter'

module Blink
    class ParseError < Racc::ParseError; end
end

---- inner ----
def file=(file)
    @lexer.file = file
end

def initialize
    @lexer = Blink::Parser::Lexer.new()
    if Blink[:debug]
        @yydebut = true
    end
end

def on_error(token,value,stack)
    #puts "Parse stack:"
    #puts stack
    #on '%s' at '%s' in\n'%s'" % [token,value,stack]
    error = "line %s: parse error after '%s'" % [@lexer.line,@lexer.last]

    if @lexer.file
        error += (" in '%s'" % @lexer.file)
    end

    raise Blink::ParseError.new(error)
end

# how should I do error handling here?
def parse
    yyparse(@lexer,:scan)
    #begin
    #    yyparse(@lexer,:scan)
    #rescue Racc::ParseError => detail
    #    raise Racc::ParseError.new("line %s: parse error after '%s'" %
    #        [@lexer.line,@lexer.last])
    #end
end

def string=(string)
    @lexer.string = string
end

# the parent class for all of our syntactical objects
class AST
    attr_accessor :line
    @@pink = "[0;31m"
    @@green = "[0;32m"
    @@yellow = "[0;33m"
    @@reset = "[0m"

    @@indent = " " * 4
    @@indline = @@pink + ("-" * 4) + @@reset
    @@midline = @@yellow + ("-" * 4) + @@reset

    def AST.indention
        return @@indent * @@indention
    end

    def AST.midline
        return @@midline
    end

    def typewrap(string)
        #return self.class.to_s.sub(/.+::/,'') + "(" + @@green + string +@@reset+ ")"
        return @@green + string +@@reset+ "(" + self.class.to_s.sub(/.+::/,'') + ")"
    end

    def initialize(*rest)
        begin
            args = Hash[*rest]
        rescue ArgumentError
            raise ArgumentError.new("Arguments must be passed as name => value pairs")
        end
        args.each { |param,value|
            method = param.to_s + "="
            unless self.respond_to?(method)
                raise "Invalid parameter %s to object class %s" %
                    [method,self.class.to_s]
            end

            begin
                #Blink.debug("sending %s to %s" % [method, self.class])
                self.send(method,value)
            rescue => detail
                # XXX this should be more normal error correction
                raise "Could not set parameter %s on class %s: %s" %
                    [method,self.class.to_s,detail]
            end
        }
    end

    class ASTArray < Array
        def tree(indent = 0)
            #puts((AST.indent * indent) + self.pin)
            self.collect { |child|
                child.tree(indent)
            }.join("\n" + (AST.midline * (indent+1)) + "\n")
        end
    end

    # this differentiation is used by the interpreter
    # XXX i now need a standard mechanism for descending into children

    # these objects have children
    class Branch < AST
        include Enumerable
        attr_accessor :pin

        def each
            @children.each { |child|
                yield child
            }
        end

        def tree(indent = 0)
            return ((@@indline * indent) + self.typewrap(self.pin)) + "\n" +
            self.collect { |child|
                child.tree(indent + 1)
            }.join("\n")
        end
    end

    # and these ones don't
    class Leaf < AST
        attr_accessor :value, :type

        def tree(indent = 0)
            return ((@@indent * indent) + self.typewrap(self.value))
        end

        def to_s
            return @value
        end
    end

    class String < AST::Leaf
        attr_accessor :value
    end

    class Word < AST::Leaf
        attr_accessor :value
    end

    class ObjectDef < AST::Branch
        attr_accessor :name, :object
        attr_reader :params

        def []=(index,obj)
            @params[index] = obj
        end

        def [](index)
            return @params[index]
        end

        def each
            #Blink.debug("each called on %s" % self)
            [@object,@name,@params].flatten.each { |param|
                #Blink.debug("yielding param %s" % param)
                yield param
            }
        end

        def initialize(*args)
            super(*args)
        end

        def params=(params)
            if params.is_a?(Array)
                @params = params
            else
                @params = [params]
            end
        end

        def tree(indent = 0)
            return [
                @object.tree(indent + 1),
                @name.tree(indent + 1),
                ((@@indline * indent) + self.typewrap(self.pin)),
                @params.collect { |param|
                    begin
                        param.tree(indent + 1)
                    rescue NoMethodError => detail
                        puts "failed to tree"
                        puts @params
                        p param
                        raise
                    end
                }.join("\n")
            ].join("\n")
        end

        def to_s
            return "%s => { %s }" % [@name,
                @params.collect { |param|
                    param.to_s
                }.join("\n")
            ]
        end
    end

    class ObjectParam < AST::Branch
        attr_accessor :value, :param

        def each
            [@param,@value].each { |child| yield child }
        end

        def tree(indent = 0)
            return [
                @param.tree(indent + 1),
                ((@@indline * indent) + self.typewrap(self.pin)),
                @value.tree(indent + 1)
            ].join("\n")
        end

        def to_s
            return "%s => %s" % [@param,@value]
        end
    end

    class Selector < AST::Branch
        attr_accessor :param, :value

        def tree(indent = 0)
            return [
                @param.tree(indent + 1),
                ((@@indline * indent) + self.typewrap(self.pin)),
                @value.tree(indent + 1)
            ].join("\n")
        end

        def each
            [@param,@value].each { |child| yield child }
        end
    end

    class VarDef < AST::Branch
        attr_accessor :name, :value

        def each
            [@name,@value].each { |child| yield child }
        end

        def tree(indent = 0)
            return [
                @name.tree(indent + 1),
                ((@@indline * 4 * indent) + self.typewrap(self.pin)),
                @value.tree(indent + 1)
            ].join("\n")
        end

        def to_s
            return "%s => %s" % [@name,@value]
        end
    end

    class FunctionCall < AST::Branch
        attr_accessor :name, :values

        def each
            [@name,@values].each { |child| yield child }
        end

        def tree(indent = 0)
            return [
                @name.tree(indent + 1),
                ((@@indline * 4 * indent) + self.typewrap(self.pin)),
                @values.tree(indent + 1)
            ].join("\n")
        end

        def to_s
            return "%s => %s" % [@name,@values]
        end
    end
end
