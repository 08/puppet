#!/usr/bin/env ruby

#
# = Synopsis
#
# A stand-alone Puppet filebucket client.
#
# = Usage
#
#   pbucket [-h|--help] [-V|--version] [-d|--debug] [-v|--verbose]
#      [-l|--local] [-r|--remote]
#      [-s|--server <server>] [-b|--bucket <directory>] <file> <file> ...
#
# = Description
#
# This is a stand-alone filebucket client for sending files to a local
# or central filebucket.
#
# = Options
#
# Note that any configuration parameter that's valid in the configuration file
# is also a valid long argument.  For example, 'ssldir' is a valid configuration
# parameter, so you can specify '--ssldir <directory>' as an argument.
#
# See the configuration file documentation at
# http://reductivelabs.com/projects/puppet/reference/configref.html for
# the full list of acceptable parameters. A commented list of all
# configuration options can also be generated by running puppet with
# '--genconfig'.
#
# debug::
#   Enable full debugging.
#
# help::
#   Print this help message
#
# local::
#   Use the local filebucket.  This will use the default configuration
#   information.
#
# remote::
#   Use a remote filebucket.  This will use the default configuration
#   information.
#
# server::
#   The server to send the file to, instead of locally.
#
# verbose::
#   Print extra information.
#
# version::
#   Print version information.
#
# = Example
#
#   pbucket -b /tmp/filebucket /my/file
#
# = Author
#
# Luke Kanies
#
# = Copyright
#
# Copyright (c) 2005 Reductive Labs, LLC
# Licensed under the GNU Public License

require 'puppet'
require 'puppet/server'
require 'puppet/client'
require 'getoptlong'

options = [
    [ "--bucket",   "-b",			GetoptLong::REQUIRED_ARGUMENT ],
    [ "--debug",	"-d",			GetoptLong::NO_ARGUMENT ],
    [ "--help",		"-h",			GetoptLong::NO_ARGUMENT ],
    [ "--local",	"-l",			GetoptLong::NO_ARGUMENT ],
    [ "--remote",	"-r",			GetoptLong::NO_ARGUMENT ],
    [ "--verbose",  "-v",			GetoptLong::NO_ARGUMENT ],
    [ "--version",  "-V",           GetoptLong::NO_ARGUMENT ]
]

# Add all of the config parameters as valid options.
Puppet.config.addargs(options)

result = GetoptLong.new(*options)

options = {}

begin
    result.each { |opt,arg|
        case opt
            when "--version"
                puts "%s" % Puppet.version
                exit
            when "--help"
                if Puppet.features.usage?
                    RDoc::usage && exit
                else
                    puts "No help available unless you have RDoc::usage installed"
                    exit
                end
            when "--bucket"
                options[:bucket] = arg
            when "--verbose"
                options[:verbose] = true
            when "--debug"
                options[:debug] = true
            when "--local"
                options[:local] = true
            when "--remote"
                options[:remote] = true
            else
                Puppet.config.handlearg(opt, arg)
        end
    }
rescue GetoptLong::InvalidOption => detail
    $stderr.puts "Try '#{$0} --help'"
    exit(1)
end

Puppet::Log.newdestination(:console)

client = nil
server = nil

Puppet.settraps

if options[:debug]
    Puppet::Log.level = :debug
elsif options[:verbose]
    Puppet::Log.level = :info
end

# Now parse the config
if Puppet[:config] and File.exists? Puppet[:config]
    Puppet.config.parse(Puppet[:config])
end

Puppet.genconfig
Puppet.genmanifest

begin
    if options[:local]
        path = options[:bucket] || Puppet[:bucketdir]
        client = Puppet::Client::Dipper.new(:Path => path)
    else
        client = Puppet::Client::Dipper.new(:Server => Puppet[:server])
    end
rescue => detail
    $stderr.puts detail
    if Puppet[:trace]
        puts detail.backtrace
    end
    exit(1)
end

mode = ARGV.shift
case mode
when "get":
when "send":
    ARGV.each do |file|
        unless FileTest.exists?(file)
            $stderr.puts "%s: no such file" % file
            next
        end
        unless FileTest.readable?(file)
            $stderr.puts "%s: cannot read file" % file
            next
        end
        client.backup(file)
    end
else
    raise "Invalid mode %s" % mode
end

# $Id$
