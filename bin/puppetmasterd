#!/usr/bin/ruby

#
# = Synopsis
#
# The central puppet server.  Can also function as a certificate authority.
#
# = Usage
#
#   puppetmasterd [-h|--help] [-d|--debug] [-v|--verbose] [-V|--version]
#               [-l|--logdest <syslog|console|<file>>] [--httplog <file>]
#               [-m|--manifest <site manifest>] [--noca] [-p|--port <port>]
#               [--parseonly] [-s|--ssldir <cert directory>]
#               [-c|--confdir <configuration directory>] [--vardir <var dir>]
#
# = Description
#
# This is the standalone puppet execution script; use it to execute
# individual scripts that you write.  If you need to execute site-wide
# scripts, use +puppetd+ and +puppetmasterd+.
#
# = Options
#
# autosign::
#   Enable autosign (which presents a potential security problem).  If enabled,
#   refers to the autosign configuration file at /etc/puppet/autosign.conf to
#   determine which hosts should have their certificates signed.
#
# confdir::
#   The configuration root directory, where +puppetmasterd+ defaults to looking
#   for all of its configuration files.  Defaults to +/etc/puppet+.
#
# debug::
#   Enable full debugging.  Causes the daemon not to go into the background.
#
# fsconfig::
#   Where to find the fileserver configuration file.  Defaults to
#   /etc/puppet/fileserver.conf.  If the fileserver config file exists,
#   the puppetmasterd daemon will automatically also become a fileserver.
#
# group::
#   Print this help message.
#
# group::
#   The group to run as.  Can be either a name or number.  Defaults to 'puppet'.
#
# help::
#   Print this help message.
#
# httplog::
#   Where to send http logs (which are currently separate from Puppet logs).
#   Defaults to /var/puppet/log/http.log.
#
# logdest::
#   Where to send messages.  Choose between syslog, the console, and a log file.
#   Defaults to sending messages to /var/puppet/log/puppet.log, or the console
#   if debugging or verbosity is enabled.
#
# manifest::
#   The central site manifest to use for providing clients with their individual
#   configurations.  Defaults to /etc/puppet/manifests/site.pp.
#
# noca::
#   Do not function as a certificate authority.
#
# nonodes::
#   Do not use individual node designations; each node will receive the result
#   of evaluating the entire configuration.
#
# parseonly::
#   Just parse the central manifest to verify it is syntactically correct.
#
# port::
#   The port on which to listen.  Defaults to 8139.
#
# ssldir::
#   The directory in which to store certificates.  Defaults to /etc/puppet/ssl.
#
# user::
#   The user to run as.  Can be either a name or number.  Defaults to 'user'.
#
# vardir::
#   The variable-size directory, used for storing state.  Defaults to
#   /var/puppet.
#
# verbose::
#   Enable verbosity.  Causes the daemon not to go into the background.
#
# version::
#   Print the puppet version number and exit.
#
# = Example
#
#   puppetmasterd
#
# = Author
#
# Luke Kanies
#
# = Copyright
#
# Copyright (c) 2005 Reductive Labs, LLC
# Licensed under the GNU Public License

require 'getoptlong'
require 'puppet'
require 'puppet/server'

result = GetoptLong.new(
	[ "--autosign", "-a",			GetoptLong::NO_ARGUMENT ],
	[ "--confdir",	"-c",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--debug",	"-d",			GetoptLong::NO_ARGUMENT ],
	[ "--fsconfig",	"-f",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--help",		"-h",			GetoptLong::NO_ARGUMENT ],
	[ "--httplog",					GetoptLong::NO_ARGUMENT ],
	[ "--logdest",	"-l",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--manifest",	"-m",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--noca",         			GetoptLong::NO_ARGUMENT ],
	[ "--nonodes",         			GetoptLong::NO_ARGUMENT ],
	[ "--parseonly",   			    GetoptLong::NO_ARGUMENT ],
	[ "--port",	    "-p",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--ssldir",	"-s",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--user",	"-u",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--group",	"-g",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--vardir",	    			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--verbose",	"-v",			GetoptLong::NO_ARGUMENT ],
    [ "--version",  "-V",           GetoptLong::NO_ARGUMENT ]
)

$haveusage = true

begin
    require 'rdoc/usage'
rescue LoadError
    $haveusage = false
end

haveca = true
master = {}
ca = {}
fs = {}
args = {}
#user = Puppet[:user]
#group = Puppet[:group]
user = nil
group = nil

parseonly = false

begin
    result.each { |opt,arg|
        case opt
            when "--autosign"
                ca[:autosign] = Puppet[:autosign]
            when "--confdir"
                Puppet[:puppetconf] = arg
            when "--debug"
                Puppet[:debug] = true
                Puppet[:logdest] = :console
            when "--fsconfig"
                unless FileTest.exists?(arg)
                    $stderr.puts "File server configuration file %s does not exist" %
                        arg
                    exit(23)
                end
                fs[:Config] = arg
            when "--help"
                if $haveusage
                    RDoc::usage && exit
                else
                    puts "No help available unless you have RDoc::usage installed"
                    exit
                end
            when "--httplog"
                args[:AccessLog] = arg
            when "--manifest"
                master[:File] = arg
            when "--noca"
                haveca = false
            when "--nonodes"
                master[:UseNodes] = false
            when "--parseonly"
                parseonly = true
            when "--port"
                args[:Port] = arg
            when "--ssldir"
                Puppet[:ssldir] = arg
            when "--logdest"
                begin
                    Puppet[:logdest] = arg
                rescue => detail
                    $stderr.puts detail.to_s
                end
            when "--group"
                group = arg
            when "--user"
                user = arg
            when "--vardir"
                Puppet[:puppetvar] = arg
            when "--version"
                puts "%s" % Puppet.version
                exit
            when "--verbose"
                Puppet[:loglevel] = :info
                Puppet[:logdest] = :console
            else
                $stderr.puts "Invalid option '#{opt}'"
                exit(1)
        end
    }
rescue GetoptLong::InvalidOption => detail
    $stderr.puts "Try '#{$0} --help'"
    #$stderr.puts detail
    # FIXME RDoc::usage doesn't seem to work
    #if $haveusage
    #    RDoc::usage(1,'usage')
    #end
    exit(1)
end

require 'etc'

if group
    if group =~ /^\d+$/
        group = Integer(group)
    else
        begin
            g = Etc.getgrnam(group)
        rescue ArgumentError
            $stderr.puts "Could not find group %s" % group
        end
        group = g.gid
    end
    Process.egid = group 
    Process.gid = group 
end

if user
    if user =~ /^\d+$/
        user = Integer(user)
    else
        begin
            u = Etc.getpwnam(user)
        rescue ArgumentError
            $stderr.puts "Could not find user %s" % user
        end
        user = u.uid
    end
    Process.euid = user 
    Process.uid = user 
end

if Puppet[:loglevel] == :debug or Puppet[:loglevel] == :info or parseonly
    args[:Daemonize] = false
else
    args[:Daemonize] = true
end

handlers = {
    :Master => master,
    :Status => {},
    :Logger => {}
}


if haveca
    handlers[:CA] = ca
end

unless fs.include?(:Config)
    if File.exists?(Puppet[:fileserverconfig])
        fs[:Config] = Puppet[:fileserverconfig]
    #else
    #    Puppet.notice "File server config %s does not exist; skipping file serving" %
    #        Puppet[:fileserverconfig]
    end
end

if fs.include?(:Config)
    handlers[:FileServer] = fs
end

args[:Handlers] = handlers

begin
    # use the default, um, everything
    #server = Puppet::Server.new(:CA => ca)
    server = Puppet::Server.new(args)
rescue => detail
    $stderr.puts detail
    exit(1)
end

if parseonly
    # we would have already exited if the file weren't syntactically correct
    exit(0)
end

trap(:INT) {
    server.shutdown
}
begin
    server.start
rescue => detail
    Puppet.err "Could not start puppetmaster: %s" % detail
    exit(1)
end

# $Id$
