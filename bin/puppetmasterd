#!/usr/bin/ruby

#
# = Synopsis
#
# The central puppet server.  Can also function as a certificate authority.
#
# = Usage
#
#   puppetmasterd [-h|--help] [-d|--debug] [-v|--verbose] [-V|--version]
#               [--noca] [--nobucket]
#
# = Description
#
# This is the puppet central daemon.
#
# = Options
#
# Note that any configuration parameter that's valid in the configuration file
# is also a valid long argument.  For example, 'ssldir' is a valid configuration
# parameter, so you can specify '--ssldir <directory>' as an argument.
#
# See the configuration file for the full list of acceptable parameters.
#
# debug::
#   Enable full debugging.  Causes the daemon not to go into the background.
#
# help::
#   Print this help message.
#
# logdest::
#   Where to send messages.  Choose between syslog, the console, and a log file.
#   Defaults to sending messages to /var/puppet/log/puppet.log, or the console
#   if debugging or verbosity is enabled.
#
# nobucket::
#   Do not function as a file bucket.
#
# noca::
#   Do not function as a certificate authority.
#
# nonodes::
#   Do not use individual node designations; each node will receive the result
#   of evaluating the entire configuration.
# verbose::
#   Enable verbosity.  Causes the daemon not to go into the background.
#
# version::
#   Print the puppet version number and exit.
#
# = Example
#
#   puppetmasterd
#
# = Author
#
# Luke Kanies
#
# = Copyright
#
# Copyright (c) 2005 Reductive Labs, LLC
# Licensed under the GNU Public License

require 'getoptlong'
require 'puppet'
require 'puppet/server'

options = [
	[ "--debug",	"-d",			GetoptLong::NO_ARGUMENT ],
	[ "--help",		"-h",			GetoptLong::NO_ARGUMENT ],
	[ "--logdest",	"-l",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--noca",         			GetoptLong::NO_ARGUMENT ],
	[ "--nobucket",        			GetoptLong::NO_ARGUMENT ],
	[ "--nonodes",         			GetoptLong::NO_ARGUMENT ],
	[ "--verbose",	"-v",			GetoptLong::NO_ARGUMENT ],
    [ "--version",  "-V",           GetoptLong::NO_ARGUMENT ]
]
#Puppet::Log.newdestination(:syslog)

# Add all of the config parameters as valid options.
Puppet.config.addargs(options)

result = GetoptLong.new(*options)

$haveusage = true

begin
    require 'rdoc/usage'
rescue LoadError
    $haveusage = false
end

haveca = true
master = {}
ca = {}
fs = {}
bucket = {}
args = {}
#user = Puppet[:user]
#group = Puppet[:group]
user = nil
group = nil

havebucket = true

parseonly = false

setdest = false

begin
    result.each { |opt,arg|
        case opt
            when "--debug"
                Puppet::Log.level = :debug
                Puppet::Log.newdestination(:console)
            when "--help"
                if $haveusage
                    RDoc::usage && exit
                else
                    puts "No help available unless you have RDoc::usage installed"
                    exit
                end
            when "--noca"
                haveca = false
            when "--nobucket"
                havebucket = false
            when "--nonodes"
                master[:UseNodes] = false
            when "--logdest"
                begin
                    Puppet::Log.newdestination(arg)
                    setdest = true
                rescue => detail
                    $stderr.puts detail.to_s
                end
            when "--version"
                puts "%s" % Puppet.version
                exit
            when "--verbose"
                Puppet::Log.level = :info
                Puppet::Log.newdestination :console
            else
                Puppet.config.handlearg(opt, arg)
        end
    }
rescue GetoptLong::InvalidOption => detail
    $stderr.puts "Try '#{$0} --help'"
    #$stderr.puts detail
    # FIXME RDoc::usage doesn't seem to work
    #if $haveusage
    #    RDoc::usage(1,'usage')
    #end
    exit(1)
end
ca[:autosign] = Puppet[:autosign]

# Now parse the config
if Puppet[:config] and File.exists? Puppet[:config]
    Puppet.config.parse(Puppet[:config])
end

Puppet.genconfig
Puppet.genmanifest

require 'etc'

Puppet::Util.chuser

if Puppet::Log.level == :debug or Puppet::Log.level == :info or parseonly
    args[:Daemonize] = false
else
    args[:Daemonize] = true
end

handlers = {
    :Master => master,
    :Status => {},
    :Logger => {}
}

unless setdest
    Puppet::Log.newdestination(:syslog)
end

if haveca
    handlers[:CA] = ca
end

#if havebucket
#    handlers[:FileBucket] = bucket
#end

if File.exists?(Puppet[:fileserverconfig])
    fs[:Config] = Puppet[:fileserverconfig]
#else
#    Puppet.notice "File server config %s does not exist; skipping file serving" %
#        Puppet[:fileserverconfig]
end

if fs.include?(:Config)
    handlers[:FileServer] = fs
end

args[:Handlers] = handlers

begin
    # use the default, um, everything
    #server = Puppet::Server.new(:CA => ca)
    server = Puppet::Server.new(args)
rescue => detail
    $stderr.puts detail
    exit(1)
end

if Puppet[:parseonly]
    # we would have already exited if the file weren't syntactically correct
    exit(0)
end

if args[:Daemonize]
    server.daemonize
end

trap(:INT) {
    server.shutdown
}

Puppet.notice "Starting Puppet server version %s" % [Puppet.version]

begin
    server.start
rescue => detail
    Puppet.err "Could not start puppetmaster: %s" % detail
    exit(1)
end

# $Id$
