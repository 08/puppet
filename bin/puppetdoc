#!/usr/bin/ruby

#
# = Synopsis
#
# Generate a reference for all Puppet types.  Largely meant for internal Reductive
# Labs use.
#
# = Usage
#
#   puppetdoc [-h|--help]
#
# = Description
#
# This command generates a restructured-text document describing all installed
# Puppet types.  It is largely meant for internal use and is used to generate
# the reference document available on the Reductive Labs web site.
#
# = Options
#
# help::
#   Print this help message
#
# = Example
#
#   $ puppetdoc > /tmp/reference.rst
#
# = Author
#
# Luke Kanies
#
# = Copyright
#
# Copyright (c) 2005 Reductive Labs, LLC
# Licensed under the GNU Public License

require 'puppet'
require 'getoptlong'

$haveusage = true

begin
    require 'rdoc/usage'
rescue
    $haveusage = false
end

def tab(num)
    return $tab * num
end

result = GetoptLong.new(
	[ "--help",		"-h",			GetoptLong::NO_ARGUMENT ]
)

debug = false

$tab = "   "

begin
    result.each { |opt,arg|
        case opt
            when "--help"
                if $haveusage
                    RDoc::usage && exit
                else
                    puts "No help available unless you have RDoc::usage installed"
                    exit
                end
        end
    }
rescue GetoptLong::InvalidOption => detail
    $stderr.puts "Try '#{$0} --help'"
    #if $haveusage
    #    RDoc::usage_no_exit('usage')
    #end
    exit(1)
end

puts %{
==============
Type Reference
==============

}

types = {}
Puppet::Type.eachtype { |type|
    types[type.name] = type
}
puts %{
---------------
Meta-Parameters
---------------

}
Puppet::Type.eachmetaparam { |param|
    puts "- **" + param.to_s + "**"
    puts tab(1) + Puppet::Type.metaparamdoc(param).gsub(/\n\s*/,' ')
}

puts %{
-----
Types
-----

- *namevar* is the parameter used to uniquely identify a type instance.
  This is the parameter that gets assigned when a string is provided before
  the colon in a type declaration.
- *states* are the aspects of a type that can be changed.
- *params* control how a type implements the state changes.


}

types.sort { |a,b|
    a.to_s <=> b.to_s
}.each { |name,type|
    next if name == :puppet
    next if name == :component

    puts "

----------------

"

    puts "
%s
%s" % [name, "=" * (name.to_s.length + 4)]
    #String.new('n%s\n') % name.to_s
    #puts "**" + type.doc.gsub(/\n\s*/, ' ') + "**\n\n"
    puts type.doc.gsub(/\n\s*/, ' ') + "\n\n"
    type.buildstatehash
    #puts tab(1) + "* namevar: %s" % type.namevar
    docs = {}
    #puts "%s States\n'''''''''''''''''''''''''''''''" % name.to_s.capitalize
    type.validstates.sort { |a,b|
        a.to_s <=> b.to_s
    }.reject { |sname,state|
        state.nodoc
    }.each { |sname,state|
        docs[sname] = state.doc.gsub(/\n\s*/,' ')
        #puts "- **%s**" % sname
        #puts tab(1) + state.doc.gsub(/\n\s*/,' ')
    }

    puts "\n%s Parameters\n''''''''''''''''''''''''''''''" % name.to_s.capitalize
    type.parameters.sort { |a,b|
        a.to_s <=> b.to_s
    }.each { |name,param|
        docs[name] = type.paramdoc(name).gsub(/\n\s*/,' ')
    }

    docs.sort { |a, b|
        a[0].to_s <=> b[0].to_s
    }.each { |name, doc|
        print "- **%s**" % name
        if type.namevar == name and name != :name
            puts " (*namevar*)"
        else
            puts ""
        end
        puts tab(1) + doc
    }
    puts "\n"
}

puts "

----------------

"

puts "\n*This page autogenerated on %s*" % Time.now
# $Id$
