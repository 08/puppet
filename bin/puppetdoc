#!/usr/bin/env ruby

#
# = Synopsis
#
# Generate a reference for all Puppet types.  Largely meant for internal Reductive
# Labs use.
#
# = Usage
#
#   puppetdoc [-h|--help] [-m|--mode <typedocs|configref>
#
# = Description
#
# This command generates a restructured-text document describing all installed
# Puppet types or all allowable arguments to puppet executables.  It is largely
# meant for internal use and is used to generate the reference document
# available on the Reductive Labs web site.
#
# = Options
#
# help::
#   Print this help message
#
# mode::
#   Print documentation of a given type.  Valid optinos are 'typedocs', for
#   resource type documentation, and 'configref', for documentation on all
#   of the configuration parameters.
#
# = Example
#
#   $ puppetdoc > /tmp/reference.rst
#
# = Author
#
# Luke Kanies
#
# = Copyright
#
# Copyright (c) 2005 Reductive Labs, LLC
# Licensed under the GNU Public License

require 'puppet'
require 'puppet/network/handler'
require 'getoptlong'

result = GetoptLong.new(
	[ "--mode",	"-m",			GetoptLong::REQUIRED_ARGUMENT ],
	[ "--help",		"-h",			GetoptLong::NO_ARGUMENT ]
)

debug = false

$tab = "    "

mode = :typedocs

begin
    result.each { |opt,arg|
        case opt
            when "--mode"
                mode = arg.intern
            when "--help"
                if Puppet.features.usage?
                    RDoc::usage && exit
                else
                    puts "No help available unless you have RDoc::usage installed"
                    exit
                end
        end
    }
rescue GetoptLong::InvalidOption => detail
    $stderr.puts "Try '#{$0} --help'"
    exit(1)
end

include Puppet::Util::Docs

# Indent every line in the chunk except those which begin with '..'.
def indent(text, tab)
    return text.gsub(/(^|\A)/, tab).gsub(/^ +\.\./, "..")
end

def paramwrap(name, text, namevar = false)
    if namevar
        name = name.to_s + " (*namevar*)"
    end

    puts "#### %s" % name
    puts text

    puts ""
end

# Print the docs for arguments
def self.configref
    docs = {}
    Puppet.config.each do |name, object|
        docs[name] = object
    end

    docs.sort { |a, b|
        a[0].to_s <=> b[0].to_s
    }.each do |name, object|
        # Make each name an anchor
        puts %{#### <a name="#{name.to_s}">#{name.to_s}</a> (<em>#{object.section.to_s}</em>)}

        puts ""
        default = ""
        if val = object.value and val != ""
            default = "  ``%s``" % val
        end
        begin
            puts object.desc.gsub(/\n/, " ") + default
        rescue => detail
            puts detail.backtrace
            puts detail
        end
        puts ""
    end

end

# Print the docs for types
def self.typedocs
    types = {}
    Puppet::Type.loadall

    Puppet::Type.eachtype { |type|
        next if type.name == :puppet
        next if type.name == :component
        types[type.name] = type
    }

    # Build a simple TOC
    puts "## Table of Contents"
    puts "1. <a href='#meta-parameters'>Meta-Parameters</a>"
    types.sort { |a, b| a[0].to_s <=> b[0].to_s }.each do |name, type|
        puts "1. <a href='#%s'>%s</a>" % [type.name, type.name.to_s.capitalize]
    end

    puts %{
<h2><a name="meta-parameters">Meta-Parameters</a></h2>

Metaparameters are parameters that work with any element; they are part of the
Puppet framework itself rather than being part of the implementation of any
given instance.  Thus, any defined metaparameter can be used with any instance
in your manifest, including defined components.

    }
    begin
        params = []
        Puppet::Type.eachmetaparam { |param|
            params << param
        }

        params.sort { |a,b|
            a.to_s <=> b.to_s
        }.each { |param|
            paramwrap(param.to_s, scrub(Puppet::Type.metaparamdoc(param)))
            #puts "<dt>" + param.to_s + "</dt>"
            #puts tab(1) + Puppet::Type.metaparamdoc(param).scrub.indent($tab)gsub(/\n\s*/,' ')
            #puts "<dd>"
            #puts indent(scrub(Puppet::Type.metaparamdoc(param)), $tab)
            #puts scrub(Puppet::Type.metaparamdoc(param))
            #puts "</dd>"

            #puts ""
        }
    rescue => detail
        puts detail.backtrace
        puts "incorrect metaparams: %s" % detail
        exit(1)
    end

    puts %{
## Types

- *namevar* is the parameter used to uniquely identify a type instance.
  This is the parameter that gets assigned when a string is provided before
  the colon in a type declaration.  In general, only developers will need to
  worry about which parameter is the ``namevar``.
  
  In the following code:

      file { "/etc/passwd":
          owner => root,
          group => root,
          mode => 644
      }

  "/etc/passwd" is considered the name of the file object (used for things like
  dependency handling), and because ``path`` is the namevar for ``file``, that
  string is assigned to the ``path`` parameter.

- *parameters* determine the specific configuration of the instance.  They either
  directly modify the system (internally, these are called properties) or they affect
  how the instance behaves (e.g., adding a search path for ``exec`` instances
  or determining recursion on ``file`` instances).

- *providers* provide low-level functionality for a given resource type.  This is
  usually in the form of calling out to external commands.

  When required binaries are specified for providers, fully qualifed paths
  indicate that the binary must exist at that specific path and unqualified
  binaries indicate that Puppet will search for the binary using the shell
  path.

  Resource types define features they can use, and providers can be tested to see
  which features they provide.

    }

    types.sort { |a,b|
        a.to_s <=> b.to_s
    }.each { |name,type|

        puts "

----------------

"

        puts "
<h2><a name='%s'>%s</a></h2>" % [name, name]
        puts scrub(type.doc) + "\n\n"

        # Handle the feature docs.
        if featuredocs = type.featuredocs
            puts "<h3><a name='%s_features'>%s Features</a></h3>" % [name, name.to_s.capitalize]
            puts featuredocs
        end

        docs = {}
        type.validproperties.sort { |a,b|
            a.to_s <=> b.to_s
        }.reject { |sname|
            property = type.propertybyname(sname)
            property.nodoc
        }.each { |sname|
            property = type.propertybyname(sname)

            unless property
                raise "Could not retrieve property %s on type %s" % [sname, type.name]
            end

            doc = nil
            str = nil
            unless doc = property.doc
                $stderr.puts "No docs for %s[%s]" % [type, sname]
                next
            end
            doc = doc.dup
            str = doc
            str = scrub(str)

            #str = indent(str, $tab)
            docs[sname]  = str
        }

        puts "\n### %s Parameters\n" % name.to_s.capitalize
        type.parameters.sort { |a,b|
            a.to_s <=> b.to_s
        }.each { |name,param|
            #docs[name] = indent(scrub(type.paramdoc(name)), $tab)
            docs[name] = scrub(type.paramdoc(name))
        }

        docs.sort { |a, b|
            a[0].to_s <=> b[0].to_s
        }.each { |name, doc|
            namevar = type.namevar == name and name != :name
            paramwrap(name, doc, namevar)
        }
        puts "\n"
    }
end

def self.reports
    puts Puppet::Network::Handler.report.reportdocs
end

def self.functions
    puts Puppet::Parser::Functions.functiondocs
end

unless respond_to?(mode)
    raise "Invalid mode %s" % mode
end

send(mode)

puts "

----------------

"
puts "\n*This page autogenerated on %s*" % Time.now

# $Id$
