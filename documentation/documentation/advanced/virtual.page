---
inMenu: true
title: Virtual Resources
orderInfo: 50
---

## Virtual Resources

By default, any resource you describe in a client's Puppet config will
get sent to the client and be managed by that client.  However, as of
0.20.0, resources can be specified in a way that marks them as virtual,
meaning that they will not be sent to the client by default.  You mark a
resource as virtual by prepending ``@`` to the resource specification;
for instance, the following code defines a virtual user:

    @user { luke: ensure => present }

If you include this code (or something similar) in your configuration
then the user will never get sent to your clients without some extra
effort.

## How This Is Useful

Puppet enforces configuration normalization, meaning that a given
resource can only be specified in one part of your configuration.  You
can't configure user ``johnny`` in both the ``solaris`` and ``freebsd``
classes.

For most cases, this is fine, because most resources are distinctly
related to a single Puppet class -- they belong in the ``webserver``
class, ``mailserver`` class, or whatever.  Some resources can not be
cleanly tied to a specific class, though; multiple otherwise-unrelated
classes might need a specific resource.  For instance, if you have a
user who is both a database administrator and a Unix sysadmin, you want
the user installed on all machines that have either database
administrators or Unix administrators.

You can't specify the user in the ``dba`` class nor in the ``sysadmin``
class, because that would not get the user installed for all cases that
matter.

In these cases, you can specify the user as a virtual resource, and
then mark the user as real in both classes.  Thus, the user is still
specified in only one part of your configuration, but multiple parts of
your configuration verify that the user will be installed on the client.

The important point here is that you can take a virtual resource and
mark it non-virtual as many times as you want in a configuration; it's
only the specification itself that must be normalized to one specific
part of your configuration.

## How to Realize Resources

There are two ways to mark a virtual resource so that it gets sent to
the client:  You can use a special syntax called a ``collection``, or
you can use the simple function ``realize``.  Collections provide a
simple syntax for marking virtual objects as real, such that they should
be sent to the client.  Collections require the type of resource you are
collecting and zero or more attribute comparisons to specifically select
resources.  For instance, to find our mythical user, we would use:

    User <| title == luke |>

As promised, we've got the ``user`` type (capitalized, because we're
performing a type-level operation), and we're looking for the user whose
``title`` is ``luke``.  "Title" is special here -- it is the value
before the colon when you specify the user.  This is somewhat of an
inconsistency in Puppet, because this value is often referred to as the
``name``, but many types have a ``name`` parameter and they could have
both a title and a name.

If no comparisons are specified, all virtual resources of that type will
be marked real.

This attribute querying syntax is currently very simple.  The only
comparisons available are equality and non-equality (using the ``==`` and
``!=`` operators, respectively), and you can join these comparisons
using ``or`` and ``and``.  You can also parenthesize these statements,
as you might expect.  So, a more complicated collection might look like:

    User <| (group == dba or group == sysadmin) or title == luke |>

## Realizing Resources

Puppet provides a simple form of syntactic sugar for marking 
resource non-virtual by title, the ``realize`` function:

    realize User[luke]
    realize(User[johnny], User[billy])

The function follows the same syntax as other function in the language,
except that only resource references are valid values.

## Exported Resources

Puppet provides an experimental superset of virtual resources, using a
similar syntax.  In addition to these resources being virtual, they're
also ``exported`` to other hosts on your network.  While virtual
resources can only be collected by the host that specified them,
exported resources can be collected by any host.  You must set the
``storeconfigs`` configuration parameter to ``true`` to enable this
functionality, and Puppet will automatically create a database for
storing configurations (using [Ruby on Rails](http://rubyonrails.org)).

This allows one host to configure another host; for instance, a host
could configure its services using Puppet, and then could export
Nagios configurations to monitor those services.

There are two key syntactical differences between virtual and exported
resources.  First, the special sigils are doubled for exported
resources, and second, only resource titles can be compared during a
collection of exported resources.

Here is an example with exported resources:

    class ssh {
        @@sshkey { $hostname: type => dsa, key => $sshdsakey }
        Sshkey <<| |>>
    }

As promised, we use two ``@`` sigils here, and the angle brackets are
doubled inthe collection.

The above code would have every host export its SSH public key, and then
collect every host's key and install it in the ``ssh_known_hosts`` file
(which is what the ``sshkey`` type does); this would include the host
doing the exporting.

It's important to mention here that you will only get exported resources
from hosts whose configurations have been compiled.  If hostB exports a
resource but hostB has never connected to the server, then no host will
get that exported resource.  The act of compiling a given host's
configuration puts the resources into the database, and only resources
in the database are available for collection.

### Exporting Is Still Experimental

Unfortunately, this exporting is still experimental.  We are in the
midst of revamping the database schema, in order to provide the same
level of functionality to exported objects as virtual objects have
(i.e., comparisons for any attribute).  Until this is settled, this
functionality will be relatively fluid.

*$Id$*
