---
inMenu: true
title: Providers
orderInfo: 70
---

# Providers

One of Puppet's primary goals is to function as a portable abstraction
layer above different operating systems, relieving developers and users
from the need to know how to use every command on every operating
system.  The top layer of the abstraction layer is composed of Puppet
types, such as Users, Groups, and Packages; these types provide the
modeling for how to manage a given resource, such as what attributes are
appropriate and how to validate them.

For some resource types and on some platforms, simple types are
sufficient.  In the far more common case, though, types must be
implemented differently on different platforms, and a layer exists below
the types to handle this implementation variety.  This layer is composed
of what we call ``providers``.  For example, Puppet currently supports
more than 15 different package providers, such as ``apt``, ``yum``, and
``gem``.  Puppet will usually select an appropriate provider for your
system, but you can override that default selection using the
``provider`` attribute as appropriate.

This document is meant to help you understand how to create new
providers.  They are usually quite simple, and they are a great way to
get started with Puppet development.  Puppet automatically loads
providers on demand, so you can create a new provider, drop it into your
Ruby search path, and start using it immediately.  We are also always
glad to add new providers to the main Puppet distribution.

Puppet types are not required to have providers, and not all of the core
types that ship with Puppet have yet been converted to using them, but
it is our goal to do so, and it is recommended that all new types split
the modeling and implementation into types and providers.

Any type that does have providers will automatically have a ``provider``
attribute created, and this attribute can be used to specify the
provider; otherwise, Puppet will try to determine the appropriate one.

## Provider Suitability

Providers are inherently tied to a given platform or a given tool, so
the majority of providers will usually not be suitable on a given
system.  To handle this fact, Puppet provides mechanisms for confining
providers based on their requirements.  You can confine providers to
specific platforms according to facts returned by Facter, but it is
usually best to confine them based on what binaries they require to
function.

Confinement is accomplished using two provider class methods:
``commands`` and ``confine``.

### Confinement

The most important method is ``confine``, and in fact it's used by
``commands``.  It supports four criteria for determining suitability:
Existence of a file, truth of a value, falseness of a value, or whether
a fact matches.  Generally the true and false tests are used in
combination with another statement; for instance, you could try to load
a library, set a value based on the results of the load, and then
confine a provider based on the value.

The ``exists`` test is mostly useful for checking for binaries, so it is
better to use the ``commands`` method in those cases as it is more
useful.

Any ``confine`` arguments that are not ``true``, ``false``, or
``exists`` are expected to be Facter facts, with a single value or an
array of values to test against.  If the host's value for that fact is
not in the list of provided values, then the host is not suitable.  Fact
names and values can be passed as strings or symbols of any case.

Here is an example using all of the tests:

    confine :exists => "/etc/pam.d"
    confine :true => defined?(ActiveRecord)
    confine :false => defined?(OtherClass)
    confine :operatingsystem => [:darwin, :solaris]

### Commands

You specify the binaries that your provider needs using the ``commands``
method; for example, this is how the ``apt`` provider confines itself to
appropriate systems:

    commands :aptget => "/usr/bin/apt-get",
        :aptcache => "/usr/bin/apt-cache",
        :preseed => "/usr/bin/debconf-set-selections"

This method does two things for you:  It calls ``confine`` with the
binary as an ``exists`` test, and it stores the value in a place that
instances can easily access it.  Instances can call ``command`` with the
name you use and get the full path back:

    execute(command(:aptget), "install", "mypkg")

Even more usefully, though, this defines an instance method with the
name you use, so you can just call this instead:

    aptget "install", "mypkg"

When you use ``commands``, you can choose whether your binary is
specified fully qualifed or unqualified.  If you do not qualify the
binary, then the provider is suitable as long as the binary is somewhere
in Puppet's search path; if the binary is fully qualified, then it must
exist at exactly that location.

### Defaults

Because hosts might often have multiple suitable providers for a given
type, you can specify that a provider is a default, based again on fact
comparisons:

    defaultfor :operatingsystem => :debian

Puppet will use the longest matching list of defaults to select a
provider, so the following provider would be chosen in preference to the
above provider:

    defaultfor :operatingsystem => :debian, :hardwaremodel => "i386"

## Provider APIs

Providers only ever interact with an instance of its associated type, so
the only class that needs to know the provider API is that associated
type.  Puppet defaults to a simple API based on attributes, but the type
can override if appropriate.  Unless you are creating a new Puppet type,
the best way to determine what your provider API is usually to look at
other providers.

By default, Puppet will just call setter and getter methods on the
provider according to the attributes being modified.  For instance, 
``user`` providers define ``uid=`` and ``uid`` methods, and the ``user``
type calls these methods to modify a user's UID.  If this API is
appropriate for your type, then you just need to implement the
validation and documentation in your type, and the provider will do the
rest.

If this API is not appropriate, however, as in packages and services,
then you can define a custom API.  Generally you would implement this by
calling different provider methods for different values; here is a
snippet of how the ``package`` provider interface is called:

    newvalue(:present, :event => :package_installed) do
        provider.install
    end

Here, the type supports multiple values for the ``ensure`` state, and
each value results in a different method being called on the provider.

## Documentation

Providers, like many other aspects of Puppet, can provide a
documentation string (in Markdown) to describe how to use them.  When
the Type reference is generated, all providers will be listed for each
type, along with each provider's doc string, the list of binaries it
requires, and for what systems it is a default.

This doc string is specified using the ``desc`` class method:

    Puppet::Type.type(:package).provide :apt do
        desc "The apt provider."
        ...
    end

# $Id$
