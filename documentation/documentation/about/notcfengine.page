---
inMenu: true
title: Puppet vs. Cfengine
orderInfo: 10
---

[Cfengine](http://www.cfengine.org) is currently the most widely
deployed configuration management tool.  In many ways,
[Puppet](/projects/puppet/) can be thought of as a next-generation
version of cfengine, in that many of puppet's design goals are
specifically derived from experience with cfengine and are meant to
overcome many of cfengine's weaknesses.  However, Puppet was developed
based on experience with many tools, and it was heavily influenced by a
lot of time spent on theory, so there are some significant differences
between Puppet and cfengine.

This document summarizes the primary advances that Puppet makes over
cfengine's current state.  Left out of this document are any process decisions
that also led to Puppet's creation (e.g., the difficulty in getting
significant changes accepted to cfengine).

# Extensibility

One of the biggest differences between Cfengine and Puppet is how easy it is
to extend Puppet.  There are many places in Puppet where you can create your
own classes and Puppet will load them automatically, making them available for
use immediately with no modification to the core.  For instance, you can
create [new native resource types](../programmers/creating-a-puppet-type.html)
(that is, types written entirely in Ruby), drop them where Ruby can find them,
and just start using them -- Puppet will automatically load those types for
you.  In addition to the types themselves, you can create
[new providers](../programmers/providers.html), to support new package
managers, for instance.  There are a few other areas that will automatically
load your extensions, such as the report handlers.

In contrast, Cfengine has a very limited interface for expansion -- you can
call out to modules using a shell interface.  This limits the interface itself
to being very simple, but it also means you don't get good logging, noop
control, or much else.

You could theoretically add new native types in C to Cfengine, but that would
require modification of the entire tree, from the lexer through the parser and
all the way through to the backend.

# Abstraction

Cfengine is a great way to scale common administrative practices -- you can
move from using SSH and a for loop to using Cfengine pretty smoothly.
However, there is just as much complexity present in either form.  You still
have to handle file contents, and you still have to manage operating system
differences yourself -- you have to know whether it's ``useradd`` or
``adduser``, whether it's ``init`` or Sun's ``SMF``, and what the format of the
filesystem tab is.

Puppet's primary goal is to provide enough abstraction so that you do not have
to know those details.  You can speak in terms of users, services, or
filesystems, and Puppet will translate them to the appropriate commands on
each system.  Puppet administrators are free to focus on the complexity of
their networks, rather than being forced to also handle that complexity plus
the complexity of the differences between the operating systems.

Puppet's development was heavily influenced by the many external modules that
its author wrote for cfengine, each module managing a separate element like
users, packages, or cron jobs, and one of Puppet's primary goals was to be
able to make it easy to expand the number of element types it can manage.

# Dedication

Puppet is supported by an organization dedicated to creating
the best system automation software, and we expect to have a staff of at
least a few people dedicated to development, support, consulting, and custom
development.  Constrast this with cfengine, which is supported by a professor
whose primary use for the software is in research into anomalies.

Cfengine's author is only now starting to invest on community involvement in
its development; while its author has always accepted patches from the
community, he has been hesitant to provide standard project features like a
version repository and a bug database, and as a result cfengine's large user
base has not resulted in a large development community.

Because Reductive Labs is a commercial enterprise dependent on customer
satisfaction for its survival, our customers will have a large say in how best
to develop Puppet, and we'll be doing everything we can to develop a strong
community just as dedicated to Puppet and server automation as we are.  Our
goal is also to have multiple developers dedicated full time to Puppet
development, which should significantly accelerate feature development
compared to cfengine.

# Language Power

While the two languages are superficially similar, the puppet language already
supports two critical features that cfengine forces you to hack around.
Puppet supports building higher level objects out of a set of low-level
objects including the ability to parameterize, and has a built-in ability to
express relationships between objects.  For instance, here is how you might
define a reusable component for creating virtual hosts for apache, as you
might deploy them on Debian:

<pre><code>
    define vhost(ip = "*:80", docroot = false, htmlsource, order = 500, ensure = "enabled") {
        # Set the docroot, if necessary
        $realdocroot = $docroot ? {
            false => "/export/docroots/$name/htdocs",
            default => $docroot
        }

        # pull down the data to serve
        file { $docroot: source => $htmlsource, recurse => true }

        # Create the vhost config file
        file { "/etc/apache2/sites-available/$name":
            content => "
<VirtualHost $ip
    ServerAdmin luke at madstop.com
    DocumentRoot $realdocroot
    ServerName $name
    ErrorLog /var/log/apache2/$name/logs/error_log
    CustomLog /var/log/apache2/$name/logs/access_log common
</VirtualHost>
",
            notify => service[apache] # restart apache if this changes
        }

        case $ensure {
            enabled: {
                # Create the link
                file { "/etc/apache2/sites-enabled/$order-$name":
                    ensure => "/etc/apache2/sites-available/$name",
                    notify => service[apache]
                }
            }
            default: {
                # Make sure the link is missing
                file { "/etc/apache2/sites-enabled/$order-$name":
                    ensure => absent,
                    notify => service[apache]
                }
            }
        }
    }
</code></pre>

Note that you could pull that virtual host configuration into an external
template if you wanted:

    # Create the vhost config file
    file { "/etc/apache/sites-available/$name":
        content => template("vhost.erb")
        notify => service[apache] # restart apache if this changes
    }

Now that you have the definition, you can reuse it as many times as you want:

    vhost { "reductivelabs.com":
        htmlsource => "/nfs/html/reductivelabs.com"
    }

    vhost { "madstop.com":
        htmlsource => "/nfs/html/madstop.com"
    }

Or you can make a bunch at once:

    vhost {
        "reductivelabs.com": htmlsource => "/nfs/html/reductivelabs.com";
        "madstop.com": htmlsource => "/nfs/html/madstop.com";
        "kanies.com":
            htmlsource => "/nfs/html/kanies.com",
            ip => "192.168.0.3:80";
        "nosite.com":
            ensure => disabled,
            htmlsource => "/nfs/html/nosite.com"
    }

This simple level of abstraction already puts you far beyond what cfengine
can do.  Any function-like abstraction in cfengine must be done with
templating tools like m4.

The initial goal is to provide ample power to express the true
complexity of a network configuration, but just as importantly we want to
support code sharing.  There has been essentially zero success in sharing
configurations within the cfengine community because of how difficult basic
abstraction is with cfengine, so one of my primary goals with the language was
to make abstraction, within a network or across one, downright easy.

# Decoupling

Puppet's parser knows how to interact with the list of available element
types, but it never knows anything about specific types.  Thus, adding a new
type only requires creating the type, you will never have to modify the parser
or anything else in the stack.  In contract, new types in cfengine require
modifications all the way through the stack, including the lexer.  Puppet will
even automatically load any new types you create -- just drop them into your
search path and you can start using them (or, even better, drop them into the
[plugins directory](configref.html) and the client will automatically
retrieve and load them).

Puppet also uses the industry-standard XMLRPC protocol for communication
between Puppet clients and servers, so the protocol is easy to study and
either end could be replaced by another service if desired.  You can write
your own tools to interact with Puppet clients, if you want.

# Development Methodology

Reductive Labs is a big believer in enhancing developer productivity.  Puppet
is being written in Ruby because it is a high-level language that is easy to
use yet provides significant productivity enhancements over low-level
languages like C.  Reductive Labs also strongly believes that unreadable code
is bad code; if you can't easily follow a code path in Puppet, then you've
found a bug.  Lastly, we assiduosly unit test our code.  We're always looking
for more ways to test our code, and every bug we quash gets turned into a unit
test so we know we'll never release that bug again.

*$Id$*
