---
inMenu: true
title: Introduction
orderInfo: 10
---
# Introduction

Puppet is a system configuration tool, generally meant to be used for
centralized, automated administration.  It consists of a simple
specification language and a library of manageable resource types.  The
language can be used to specify an entire network's configuration, and
the library can already manage most common rsources, like users,
packages, and services, and can be easily extended to support new types.

The language and library are entirely decoupled; so decoupled, in fact,
that the language is usually compiled on a central server (called the
``puppetmaster``, of course), and the results are sent to each client,
which uses the library to apply the configuration.

Puppet also includes a set of XMLRPC servers for communicating between
client and server.  The primary server is used when a client connects to
the central server to have its configuration compiled, but there are
also servers for uploading reports, retrieving files, and quite a bit
more.

Puppet is written entirely in Ruby, making it easy to maintain and fast
to develop.

# Setup

The vast majority of Puppet architectures will look like a star, with a
central server running `puppetmasterd`, and each client node running
`puppetd`, contacting that central server.  Your central manifest, which
contains the configuration for all of your nodes, needs to be on the central
server, most likely at `/etc/puppet/manifests/site.pp`.  Other than
creating this one file, Puppet is largely self-configuring.

Start the `puppetmasterd` daemon, and then tell your clients to contact that
server by specifying `-s <servername>` as arguments to `puppetd`,
replacing ``<servername>`` with the name of the server.  Alternatively,
`puppetd` defaults to looking for a server named ``puppet``, so you can just
create a CNAME for your server, so that it answers to ``puppet``.

All Puppet connections are via XMLRPC, encrypted with SSL certificates.
Because of how painful certificate management is, Puppet includes a
simple certificate authority that can generate client certificates,
along with a server for sending these certificates to the client.

As you are setting up your Puppet install, it is a good idea to run both
the server and client in verbose mode, enabled with the `-v` flag, until
you are sure everything is working.  As each new client connects, it
will send a certificate request to the server, which you will need to
sign.  To do this, run `puppetca --list` to list the certificates
waiting to be signed, and then ``puppetca --sign <name>``, replacing
``<name>`` with the name of the client whose certificate you want to
sign.  You can turn on autosigning by creating
`/etc/puppet/autosign.conf` and put the hosts, domains, or IP addresses
or ranges that you want to sign in there.

# Language

The language is declarative, and is influenced by cfengine's concept
of actions, action instances, and instance parameters (although in
Puppet we call these ``resources``).  These resources are essentially
hashes with a type and title.  For instance, here is how a file element
would look in puppet:

    file { "/etc/passwd":
        owner => root,
        group => root,
        mode => 644
    }

Puppet requires that each resource in your configuration be normalized
so that it is configured in only one place.  The title of each resource
(``/etc/passwd``, in this case) is very important, because it is how
Puppet verifies that a given resource is unique.  The occurrence of two
resources with the same type and title is a compile error.

Puppet's language only supports strings and booleans (``true`` and
``false``), and quotes are optional for alphanumeric strings.

## Resource Titles

Naming can be somewhat confusing in Puppet, because every resource can
have two names.  Each resource type has a parameter that's defined as
uniquely identifying the resource (usually called ``name``), but you can
specify a title in addition to the name.  This is because many resources
that are effectively the same have names that vary on different systems.
You could just use a selector to handle this variance, but then you
would have to duplicate that selection every time you specified a
relationship to that resource.

For instance, here is how OpenSSH might be specified:

    class ssh {
        # Retrieve the configuration file
        file { "/etc/ssh/sshd_config":
            source => "/nfs/apps/ssh/sshd_config",
            notify => Service[sshd]
        }

        service { sshd:
            name => $kernel ? {
                linux => "sshd",
                sunos => "openssh"
            },
            ensure => running
        }
    }

You can see that supporting two names here allows us to provide a
symbolic name that we can use consistently throughout our configuration.

## Variables

Because it is assumed that strings will be used far more than variables, simple
strings don't have be quoted or otherwise marked, but variables must have the
``$`` attached:

    $group = "root"

    file { "/etc/sudoers":
        group => $group
    }

Strings and booleans (``true`` and ``false``) are the only data types; even
numbers are converted to strings.  Arrays are supported, although their
behaviour is *very* limited..  One particular use of arrays is for
creating many resources at once:

    $files = ["/etc/passwd","/etc/group","/etc/fstab"]

    file { ["/etc/passwd","/etc/group","/etc/fstab"]:
        owner => root,
        group => root
    }

This implicitly iterates across the file list and performs all of the
appropriate checks.

Because ``puppet`` is a declarative language, reassigning a variable
within the same scope is a compile error.  Puppet is currently
dynamically scoped, meaning that variables are inherited from calling
scopes, although this is expected to change at some point.  

## Client Facts and Facter

Puppet clearly needs to know something about the client it is
configuring, so Puppet clients use the ``Facter`` library (an external
tool also maintained by Reductive Labs) to collect everything they can
about themselves and send that information to the server.  The server
then defines these facts as variables in the top scope of the
configuration, so they are available throughout the configuration.  This
is the case whether you are using Puppet in client/server mode or just
writing stand-alone Puppet scripts.

You can run ``facter`` with no arguments to get a full list of available
facts on a given system.  The most important facts are things like
``hostname`` and ``operatingsystem``, but many others are available,
including ``ipaddress`` and ``domain``.  You can also define your own
facts very easily and have Puppet distribute them to your clients.

## Definitions

Puppet ships with many types written in Ruby as part of the main library
and it is straightforward to add new types, but the Puppet language
also allows you to define new resource types that are collections of
multiple resources.  For instance, you could have a definition that
generates Apache virtual host configurations:

    # Versions prior to 0.19 did not support the "$" sigil in the
    # prototype
    define virtualhost($docroot) {
        file { "/etc/apache2/sites-available/$name.conf"
            content => template("vhost.erb"),
            notify => Service[apache2]
        }
    }

Note the use of the ``$name`` variable; this is equivalent to ``self``
in many other languages; it is the value you provide before the colon
when you specify resources.  Definitions are meant to be used multiple
times, so it is important that each resource contained within a
definition have a title that varies for each instance of the resource.
For instance, if you had a file with the title ``/my/file`` in a
definition, then each call to that definition would attempt to manage
that same file, which would be a compile error (again, because resources
must be normalized).

The ``template`` function used above compiles an ERb template, allowing
you to use Puppet variables in the template, making it easy to generate
any files your clients need.  Each definition has its own scope, so you
can define any variables you want and they will not be available outside
the definition.  There are many other functions available, and it is
easy to add more.

## Classes

In addition to definitions, the language supports server classes.
Classes are meant to model server aspects, and as such they are
inherently singletons.  This is one of the big differences between
classes and definitions -- classes can be included multiple times with
no harm.  The other big difference is that classes support inheritance,
and subclasses can override resources defined in their parent classes.
For instance:

    class base {
        file { "/etc/passwd":
            owner => root,
            group => root
        }
    }

    class freebsd inherits base {
        File["/etc/passwd"] { group => wheel }
    }

    case $operatingsystem {
        freebsd: { include freebsd }
        default: { include base }
    }

Notice that the syntax for overriding a resource is different than that
for initially specifying one.  Prior to 0.20.0 the specification syntax
was used for both, and overriding was much more limited.

## Importing

Files can be imported using the ``import`` command:

    import "filename"

There is currently no search path or anything; files are looked for in the same
directory as the file doing the importing.  Imports happen at
parse-time, so you cannot use variables in the name of the file being
imported.

## Control Structures

Puppet has limited control structures available, partially as an attempt
to remain declarative, but also partly because language development is
annoyingly difficult.

### Selectors

One of the primary goals of Puppet is to simplify building a single
configuration that works across multiple machines and machine classes. One
mechanism for this is a simple structure called a ``selector``; it is
similar to the trinary operator ``:?`` but supporting multiple values:

    $value = $variable ? {
        value1 => setvalue1,
        value2 => setvalue2,
        default => other
    }

This sets the variable ``$value`` depending on the value of ``$variable``.  If
it is ``value1``, then ``$value`` gets set to ``setvalue1``, else the value
gets set to ``other``.

The brackets can be in either part of the expression, or not at all:

    $value = $variable ? "value1" => "setvalue1"

A selector that doesn't match a value is a compile error.

These structures are useful for simplistic abstraction across platforms:

    file { "/etc/sudoers":
        owner => root,
        group => $operatingsystem ? {
            SunOS => root,
            Linux => root,
            FreeBSD => wheel
        }
    }

Selectors can specify default values using the ``default`` keyword.

This structure will generally be the primary mechanism for supporting
multiple platforms or environments, since it makes it very easy to
select from a list of values.

### Case Statements

Puppet currently supports a normal Case structure similar to so many other
languages:

    case $operatingsystem {
        solaris: { include sunos }
        debian: { include linux }
        default: { include $operatingsystem }
    }

As you can see, case statements also support defaults.

The difference between the case stateements and the selectors is that the
selectors just return values while the case statements can contain
Puppet code.

### If/Else

Puppet also has a very limited ``if/else`` construct:

    if $server {
        include webserver
    } else {
        include webclient
    }

The main limitation to the construct is that Puppet does not currently
support any comparison operators -- you can only test boolean values.

# Library

This section discusses some aspects of the internals of the Puppet library.
This information can be useful but is not critical for use and understanding
of Puppet.

The library is organized around modeling resource types via modifyable
attributes.  

The library is composed of two fundamental types of objects: Types and
attributes.  Attributes are things that can be configured to change one
aspect of an object (e.g., a file's owner),  and types are essentially
named collections of attributes.  So, there is a File type, and it is a
collection of all of the attributes available to modify files.

Attributes are themselves divided into three different types:

* **States** (horribly named, I know), which are the attributes that actually modify
  the system (e.g., file owner, user home directory)
* **Parameters**, which only provide extra information to the states (e.g.,
  ``recurse`` on files, package sources)
* **MetaParameters**, which are valid for any resource type (e.g.,
  schedule, subscribe)

## The Code

Puppet has a simple mini-language for creating new types, with methods
for creating the types, their attributes, and then configuring
everything, such as adding validation or expressing innate relationships
between objects (e.g., a file and its owner, or a user and the group
it's in).  Here's how you create a new type in Ruby:

    Puppet::Type.newtype(:mytype) do
        ...
    end

Once created and placed in your Ruby search path, this type will become
immediately available in the language.

You can create a type that overwrites existing types; this could be
considered a bug, but it allows Puppet to reload the files that define a
type.

There are similar class methods for creating all of the different
attributes.  Here is the simplified File type declaration:

    newstate(:ensure) do ... end
    newstate(:owner) do ... end
    newstate(:group) do ... end
    ...
    newparam(:path) do ... end

Lastly, each type must either provide a state or parameter of ':name', or it
must mark a parameter as the namevar so that the system knows what is
considered the name:

    newparam(:path) do 
        isnamevar
    end

See [Creating a Puppet Type](../programmers/creating-a-puppet-type.html) for more
information.

*$Id$*
