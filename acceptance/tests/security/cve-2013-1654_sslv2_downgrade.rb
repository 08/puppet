# CVE 2013-1654 SSL Protocol Downgrade to SSLv2
# Older versions of Ruby allow the the usage of SSLv2, the protocol
# is known to be insecure, and Puppet would negotiate any SSL connection
# Ruby allowed.
test_name "CVE 2013-1654 SSLv2 Downgrade" do

  def suitable?(host)
    suitable = false
    on host,
       %Q{#{host['puppetbindir']}/ruby -e "require 'openssl'; } +
       %q{puts OpenSSL::SSL::SSLContext::METHODS" | grep '^SSLv2$'},
       :acceptable_exit_codes => [0,1] do |test|

      suitable = test.stdout =~ /SSLv2/
    end
    suitable
  end

  if suitable?( master )
    with_master_running_on( master, '--autosign true' ) do

      agent = agents.select {|a| a['platform'] !~ /windows/ }.first
      on agent, puppet_agent( '-t' )

      certfile = on(agent, puppet_agent("--configprint hostcert")).stdout.chomp
      keyfile = on(agent, puppet_agent("--configprint hostprivkey")).stdout.chomp
      cafile = on(agent, puppet_agent("--configprint localcacert")).stdout.chomp

      openssl_call = "openssl s_client -connect #{master}:8140 " +
                     "-cert \"#{certfile}\" -key \"#{keyfile}\" -CAfile \"#{cafile}\" -ssl2 -msg < /dev/null"

      on agent, openssl_call, :acceptable_exit_codes => (0..255) do |test|
        # if server says hello, then it's okay with sslv2
        assert_no_match /SERVER-HELLO/, test.stdout
      end
    end
  else
    logger.debug( "Not testing master as SSLv2 isn't available to it" )
  end

  with_master_running_on( master, '--autosign true' ) do
    on agents, puppet_agent( '-t' )
  end

  mcertfile = on(master, puppet_master("--configprint hostcert")).stdout.chomp
  mkeyfile = on(master, puppet_master("--configprint hostprivkey")).stdout.chomp
  mcafile = on(master, puppet_master("--configprint localcacert")).stdout.chomp

  sslserver = <<END
#!/usr/bin/env ruby
require 'rubygems'
require 'webrick'
require 'webrick/https'

class Servlet < WEBrick::HTTPServlet::AbstractServlet
  def do_GET(request, response)
    response.status = 200
    response['Content-Type'] = 'text/pson'
    response.body = 'FOOBAR'
  end
end

class SSLServer
  def run
    config = {}
    config[:Port] = 8140
    config[:SSLCACertificateFile] = '#{mcafile}'
    config[:SSLCertificate] =  OpenSSL::X509::Certificate.new(File.read('#{mcertfile}'))
    config[:SSLPrivateKey] = OpenSSL::PKey::RSA.new(File.read('#{mkeyfile}'))
    config[:SSLStartImmediately] = true
    config[:SSLEnable] = true
    config[:SSLVerifyClient] = OpenSSL::SSL::VERIFY_NONE

    server = WEBrick::HTTPServer.new(config)
    server.mount('/', Servlet)
    server.ssl_context.ssl_version = 'SSLv2'
    trap :TERM do
      exit!(0)
    end
    server.start
  end
end

if $0 == __FILE__
  SSLServer.new.run
end
END

  testdir = master.tmpdir('puppet-sslv2')
  teardown do
    on(master, "ps -ef | grep -E 'sslserver.rb' | grep -v grep | awk '{ print $2 }' | xargs kill || echo \"ruby sslserver.rb not running\"")
    on(master, "rm -rf #{testdir}/sslserver.rb")
  end

  create_remote_file(master, "#{testdir}/sslserver.rb", sslserver)
  on master, "ruby #{testdir}/sslserver.rb &>/dev/null &"

  timeout = 15
  begin
    Timeout.timeout(timeout) do
      loop do
        # 7 is "Could not connect to host", which will happen before it's running
        result = on(master, "curl -m1 -k https://#{master}:8140", :acceptable_exit_codes => [0,7,35])
        break if result.exit_code == 0 or result.exit_code == 35
        sleep 1
      end
    end
  rescue Timeout::Error
    fail_test "Insecure Mock Server on #{master} failed to start after #{timeout} seconds"
  end

  agents.each do |agent|
    if suitable?( agent )
      on(agent, puppet("agent --debug --test --server #{master}"), :acceptable_exit_codes => [1]) do |test|
        assert_no_match(/'FOOBAR'/, test.stdout)
      end
    else
      logger.debug( "skipping #{agent} since SSLv2 is not available" )
    end
  end
end
